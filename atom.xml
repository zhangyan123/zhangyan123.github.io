<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张言的博客</title>
  <subtitle>记录前端开发学习与积累</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangyan123.github.io/"/>
  <updated>2018-01-19T08:52:15.000Z</updated>
  <id>http://zhangyan123.github.io/</id>
  
  <author>
    <name>张言</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Py定制类</title>
    <link href="http://zhangyan123.github.io/2018/01/20/Py%E5%AE%9A%E5%88%B6%E7%B1%BB/"/>
    <id>http://zhangyan123.github.io/2018/01/20/Py定制类/</id>
    <published>2018-01-20T07:50:00.000Z</published>
    <updated>2018-01-19T08:52:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特殊方法（魔术方法）"><a href="#特殊方法（魔术方法）" class="headerlink" title="特殊方法（魔术方法）"></a>特殊方法（魔术方法）</h1><ul>
<li>特殊方法定义在class中，不需要直接调用，Python的某些函数或操作符会自动调用对应的特殊方法。</li>
<li><p><strong>str</strong> 在print打印时调用对象的<strong>str</strong>函数并打印返回值，<strong>repr</strong>是class中自带的方法，不需要声明，当直接打印类名是调用<strong>repr</strong>返回值。通常为保持一致，我们会令<code>__repr__=__str__</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Person(object):</div><div class="line">    def __init__(self, name, gender):</div><div class="line">        self.name = name</div><div class="line">        self.gender = gender</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;(Person: %s, %s)&apos; % (self.name, self.gender)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>len</strong>,只要正确实现了<strong>len</strong>()方法，就可以用len()函数返回实例的“长度”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Students(object):</div><div class="line">    def __init__(self, *args):</div><div class="line">        self.names = args</div><div class="line">    def __len__(self):</div><div class="line">        return len(self.names)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>cmp</strong>,对 int、str 等内置数据类型排序时，Python的 sorted() 按照默认的比较函数 cmp 排序，但是，如果对一组 Student 类的实例排序时，就必须提供我们自己的特殊方法 <strong>cmp</strong>() ,注意return 1 表示交换位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">    def __init__(self, name, score):</div><div class="line">        self.name = name</div><div class="line">        self.score = score</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;(%s: %s)&apos; % (self.name, self.score)</div><div class="line">    __repr__ = __str__</div><div class="line"></div><div class="line">    def __cmp__(self, s):</div><div class="line">        if self.name &lt; s.name:</div><div class="line">            return -1</div><div class="line">        elif self.name &gt; s.name:</div><div class="line">            return 1</div><div class="line">        else:</div><div class="line">            return 0</div></pre></td></tr></table></figure>
</li>
<li><p>@property举例说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">    def __init__(self, name, score):</div><div class="line">        self.name = name</div><div class="line">        self.__score = score</div><div class="line">    @property</div><div class="line">    def score(self):</div><div class="line">        return self.__score</div><div class="line">    @score.setter</div><div class="line">    def score(self, score):</div><div class="line">        if score &lt; 0 or score &gt; 100:</div><div class="line">            raise ValueError(&apos;invalid score&apos;)</div><div class="line">        self.__score = score</div></pre></td></tr></table></figure>
</li>
<li><p><strong>slots</strong>,如果要限制添加的属性，例如，Student类只允许添加 name、gender和score 这3个属性，就可以利用Python的一个特殊的<strong>slots</strong>来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Student(object):</div><div class="line">    __slots__ = (&apos;name&apos;, &apos;gender&apos;, &apos;score&apos;)</div><div class="line">    def __init__(self, name, gender, score):</div><div class="line">        self.name = name</div><div class="line">        self.gender = gender</div><div class="line">        self.score = score</div></pre></td></tr></table></figure>
</li>
<li><p><strong>call</strong>，python中函数其实只是一个对象，它的不同之处在于可以被<code>（）</code>操作符调用，执行<code>（）</code>操作符时候实际执行了<strong>call</strong>定义的代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Person(object):</div><div class="line">    def __init__(self, name, gender):</div><div class="line">        self.name = name</div><div class="line">        self.gender = gender</div><div class="line"></div><div class="line">    def __call__(self, friend):</div><div class="line">        print &apos;My name is %s...&apos; % self.name</div><div class="line">        print &apos;My friend is %s...&apos; % friend</div></pre></td></tr></table></figure>
</li>
</ul>
<p></p><p style="color:red">注意：根据例子可以看出定制类中不同方法的使用还是存在明显差异的，大部分要求返回值，<strong>call</strong>只是定义需要执行的代码块。大部分特殊方法是在class中声明的，但是<strong>repr</strong>和<strong>slots</strong>很明显是class生来就有的，不需要声明，只做赋值即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;特殊方法（魔术方法）&quot;&gt;&lt;a href=&quot;#特殊方法（魔术方法）&quot; class=&quot;headerlink&quot; title=&quot;特殊方法（魔术方法）&quot;&gt;&lt;/a&gt;特殊方法（魔术方法）&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;特殊方法定义在class中，不需要直接调用，Python的某些函
    
    </summary>
    
      <category term="后端学习" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/"/>
    
      <category term="基本语法" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://zhangyan123.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Py函数式编程</title>
    <link href="http://zhangyan123.github.io/2018/01/18/Py%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://zhangyan123.github.io/2018/01/18/Py面向对象编程/</id>
    <published>2018-01-18T10:50:05.000Z</published>
    <updated>2018-01-19T06:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Person(object):</div><div class="line">    def __init__(self,name,gender):</div><div class="line">        self.name = name</div><div class="line">        self.__gender = gender</div><div class="line">        print(&apos;I am a Person&apos;)</div><div class="line">    def get_gender(self):</div><div class="line">        return self.__gender</div></pre></td></tr></table></figure>
<p>其中<strong>init</strong>()方法是构造函数必须的方法，用于实例初始化，生成一个新的对象并绑定对象上的属性，第一个参数必须是self指向新的对象；其余实例方法定义中第一个参数保证是self即可，实例方法可以访问class中的私有变量（<code>__</code>开头的变量）；</p>
<ul>
<li><p>继承超类的子类想要继承超类的方法与属性需要在初始化函数中调用super().<strong>init</strong>()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Teacher(Person):</div><div class="line">    def __init__(self,name,gender,teacherCode):</div><div class="line">        super(Teacher,self).__init__(name,gender)</div><div class="line">        self.teacherCode = teacherCode</div><div class="line">        print(&apos;I am a Teacher!&apos;)</div></pre></td></tr></table></figure>
</li>
<li><p>Python 支持多继承，一个子类可以继承多个超类的属性和方法，如果超类之间有共同的超类，重合部分只初始化一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class FootballSkilled(Person):</div><div class="line">    def __init__(self,name,gender):</div><div class="line">       super(FootballSkilled,self).__init__(name,gender)</div><div class="line">       print(&apos;I can play football!&apos;)</div><div class="line">class FootballSkilledTeacher(FootballSkilled,Teacher):</div><div class="line">    def __init__(self,*args):</div><div class="line">        super(FootballSkilledTeacher,self).__init__(*args)</div><div class="line">        super(FootballSkilled,self).__init__(*args)</div><div class="line">        print(&apos;I am a FootballSkilledTeacher!&apos;)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在继承多类中传递参数时报错，待解决。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类的定义&quot;&gt;&lt;a href=&quot;#类的定义&quot; class=&quot;headerlink&quot; title=&quot;类的定义&quot;&gt;&lt;/a&gt;类的定义&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="后端学习" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/"/>
    
      <category term="基本语法" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://zhangyan123.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Py函数式编程</title>
    <link href="http://zhangyan123.github.io/2018/01/16/Py%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://zhangyan123.github.io/2018/01/16/Py函数式编程/</id>
    <published>2018-01-16T13:50:05.000Z</published>
    <updated>2018-01-17T13:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组操作高阶函数介绍"><a href="#数组操作高阶函数介绍" class="headerlink" title="数组操作高阶函数介绍"></a>数组操作高阶函数介绍</h1><ul>
<li><p>map()</p>
</li>
<li><p>reduce()</p>
</li>
<li><p>filter()</p>
</li>
<li><p>sorted() 可以应用于任何iterable 数据类型，不止于数组类型</p>
</li>
</ul>
<h1 id="lambda表达式介绍（有限制的匿名函数支持）"><a href="#lambda表达式介绍（有限制的匿名函数支持）" class="headerlink" title="lambda表达式介绍（有限制的匿名函数支持）"></a>lambda表达式介绍（有限制的匿名函数支持）</h1><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><ul>
<li><p>无参数装饰器</p>
</li>
<li><p>带参数装饰器</p>
</li>
<li><p>functools.wraps(f)应用</p>
</li>
</ul>
<h1 id="偏函数-functools-partials-func-propName-XXX"><a href="#偏函数-functools-partials-func-propName-XXX" class="headerlink" title="偏函数 functools.partials(func,propName = XXX)"></a>偏函数 functools.partials(func,propName = XXX)</h1><p>注意： python安装模块式要在cmd环境下，而非python交互模式下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组操作高阶函数介绍&quot;&gt;&lt;a href=&quot;#数组操作高阶函数介绍&quot; class=&quot;headerlink&quot; title=&quot;数组操作高阶函数介绍&quot;&gt;&lt;/a&gt;数组操作高阶函数介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;map()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;reduce
    
    </summary>
    
      <category term="后端学习" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/"/>
    
      <category term="基本语法" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://zhangyan123.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Py列表生成器</title>
    <link href="http://zhangyan123.github.io/2018/01/16/Py%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://zhangyan123.github.io/2018/01/16/Py列表生成器/</id>
    <published>2018-01-16T10:50:05.000Z</published>
    <updated>2018-01-16T08:33:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>列表生成器是Python特有的生成list的便捷方式</p>
<ul>
<li><code>[x*x for x in range(1,101)]</code>生成了1到100每个数值平方组成的list集合，可见首先写的迭代返回值表达式，之后是for迭代表达式；</li>
<li><p>zip()函数可以把两个 list 变成一个 list：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; zip([10, 20, 30], [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])</div><div class="line">[(10, &apos;A&apos;), (20, &apos;B&apos;), (30, &apos;C&apos;)]</div></pre></td></tr></table></figure>
</li>
<li><p><code>[x * x for x in range(1, 11) if x % 2 == 0]</code>可以生成1到10中偶数的list集合,方法是在for迭代表达式后面加一句if表达式进行过滤。</p>
</li>
<li><code>[m + n for m in &#39;ABC&#39; for n in &#39;123&#39;]</code>可以生成[‘A1’, ‘A2’, ‘A3’, ‘B1’, ‘B2’, ‘B3’, ‘C1’, ‘C2’, ‘C3’]，叫做多层表达式，可以结合if表达式生成极其复杂的list集合。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列表生成器是Python特有的生成list的便捷方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[x*x for x in range(1,101)]&lt;/code&gt;生成了1到100每个数值平方组成的list集合，可见首先写的迭代返回值表达式，之后是for迭代表达式；&lt;/li&gt;

    
    </summary>
    
      <category term="后端学习" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/"/>
    
      <category term="基本语法" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://zhangyan123.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Py迭代</title>
    <link href="http://zhangyan123.github.io/2018/01/16/Py%E8%BF%AD%E4%BB%A3/"/>
    <id>http://zhangyan123.github.io/2018/01/16/Py迭代/</id>
    <published>2018-01-16T10:40:05.000Z</published>
    <updated>2018-01-16T07:31:22.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：<ol>
<li>有序集合：list，tuple，str和unicode；</li>
<li>无序集合：set</li>
<li>无序集合并且具有 key-value 对：dict</li>
</ol>
</li>
<li><code>enumerate()</code>函数把简单元素集合转化为tuple集合，每个tuple第一个元素为索引号，第二个元素为元素值；</li>
<li><span style="color:red">注意</span><code>range(1,4)</code>产生的结果只有3个元素（[1,2,3]）,可以与切片规律一起记为起始位置包括，结束位置不包括;</li>
<li><p>我们发现python中的dict比其他语言更易于被操作，<code>d.values()</code>和<code>d.itervalues()</code>，可以帮助我们获取到dict的值，应用for迭代就可以取到每一个属性值并应用于计算。<code>items()</code>方法可以将对象的每一组键值对封装成为一个tuple,可想而知我们就可以使用两个变量依次获取到每一组键值对中的key和value。和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。</p>
</li>
<li><p>本节主要讲的如何遍历获取集合中的属性和值，以便进行计算筛选等。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：&lt;ol&gt;
&lt;li&gt;有序集合：list，tuple，str和unicode；&lt;/li&gt;
&lt;li&gt;无序集合：set&lt;/li&gt;
&lt;li&gt;无序集合并且具有 key-value 对：dict&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="后端学习" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/"/>
    
      <category term="基本语法" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://zhangyan123.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Py切片</title>
    <link href="http://zhangyan123.github.io/2018/01/15/Py%E5%88%87%E7%89%87/"/>
    <id>http://zhangyan123.github.io/2018/01/15/Py切片/</id>
    <published>2018-01-15T13:45:05.000Z</published>
    <updated>2018-01-15T14:12:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>list、tuple、str都可以使用切片快速有效的得到新的子集合（或子字符串）；</p>
<ul>
<li>【开始位置：结束位置：步长】</li>
<li>创建的新子串包括开始位置元素，不包括结束位置元素</li>
<li><code>[-3,-1,2]</code>意思为从倒数第三个元素开始取，取到倒数第一个时刻结束，不存储倒数第一个元素，得到的子串取第一个元素，之后每间隔4个元素存一个。</li>
<li><code>[::2]</code>省略写法，第一个参数不写表示从0索引开始取值，第二个参数不写表示一直取值到最后一个。可见想取到最后一个元素的方法是第二个参数不写。</li>
<li>返回的数据保持原数据的数据类型</li>
<li>复制一个新数组与原数据数据一致的简单方法 <code>new_arr = old_arr[::]</code>(第三个参数为可选参数，不写时默认步长为1)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;list、tuple、str都可以使用切片快速有效的得到新的子集合（或子字符串）；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【开始位置：结束位置：步长】&lt;/li&gt;
&lt;li&gt;创建的新子串包括开始位置元素，不包括结束位置元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[-3,-1,2]&lt;/code&gt;意思
    
    </summary>
    
      <category term="后端学习" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/"/>
    
      <category term="基本语法" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://zhangyan123.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Py函数</title>
    <link href="http://zhangyan123.github.io/2018/01/15/Py%E5%87%BD%E6%95%B0/"/>
    <id>http://zhangyan123.github.io/2018/01/15/Py函数/</id>
    <published>2018-01-15T13:40:05.000Z</published>
    <updated>2018-01-15T12:37:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def func_name(*args):</div><div class="line">    #something about args</div><div class="line">    return sth  #默认return None</div></pre></td></tr></table></figure>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><ul>
<li>必选参数在左，默认参数在右，因为解释器对命名参数变量赋值的顺序是从左至右的；</li>
</ul>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><ul>
<li>args为存储了tuple实例的局部变量</li>
</ul>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul>
<li>python以函数为作用域 </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义方法&quot;&gt;&lt;a href=&quot;#定义方法&quot; class=&quot;headerlink&quot; title=&quot;定义方法&quot;&gt;&lt;/a&gt;定义方法&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="后端学习" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/"/>
    
      <category term="基本语法" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://zhangyan123.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Py无序集合类型</title>
    <link href="http://zhangyan123.github.io/2018/01/15/Py%E6%97%A0%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
    <id>http://zhangyan123.github.io/2018/01/15/Py无序集合类型/</id>
    <published>2018-01-15T12:40:05.000Z</published>
    <updated>2018-01-18T07:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dict-字典类型"><a href="#dict-字典类型" class="headerlink" title="dict(字典类型)"></a>dict(字典类型)</h1><ul>
<li>dict是一种用空间换取时间的无序列表结构，查询速度快，key值不可重复；</li>
<li>key值不可变</li>
<li>dict也继承自interable,可使用for循环迭代遍历</li>
<li>向dict中添加属性 setattr(obj,key,value)</li>
</ul>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><ul>
<li>调用方式向set()构造函数中传入一个list</li>
<li>set使用无序的存储方式，不能用数字索引查找元素，可以使用<code>in</code>查看元素是否在set实例中,set也继承自interable类，可使用for迭代遍历</li>
<li>set中的元素无重复项</li>
<li>使用：将有限的有效值存储进set中，对用户输入进行验证（in）</li>
<li>添加add</li>
<li>删除remove</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;dict-字典类型&quot;&gt;&lt;a href=&quot;#dict-字典类型&quot; class=&quot;headerlink&quot; title=&quot;dict(字典类型)&quot;&gt;&lt;/a&gt;dict(字典类型)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;dict是一种用空间换取时间的无序列表结构，查询速度快，key值不可
    
    </summary>
    
      <category term="后端学习" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/"/>
    
      <category term="基本语法" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://zhangyan123.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Py语句注意事项</title>
    <link href="http://zhangyan123.github.io/2018/01/15/Py%E8%AF%AD%E5%8F%A5/"/>
    <id>http://zhangyan123.github.io/2018/01/15/Py语句/</id>
    <published>2018-01-15T12:15:03.000Z</published>
    <updated>2018-01-15T07:55:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="if分支语句"><a href="#if分支语句" class="headerlink" title="if分支语句"></a>if分支语句</h1><ul>
<li><span style="color:red">注意Python代码的缩进规则。</span>具有相同缩进的代码被视为代码块构成一个代码块。缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。</li>
</ul>
<ul>
<li><p>注意: if 语句后接表达式，然后用<code>:</code>表示代码块开始.else及<span style="color:red">elif(注意写法与其他语言中else if的区别)语句表达式之后也都带<code>:</code>,之后讲到的循环语句中的for表达式及while表达式后面都要跟<code>:</code>，如果忘记加<code>:</code>会报语义错误，不能正常解释表达式。</span></p>
</li>
<li><p>如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车</p>
</li>
<li>表达式中涉及到逻辑运算符，需注意，Python中逻辑运算符与其他语言不同之处，不实用 <code>&amp;  ！ ||</code>符号，而使用对应单词<code>and not or</code>   </li>
</ul>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li>Python中的for循环用法与php很像，只要L是继承自iterable类，便可以用for循环遍历L中的各项元素。[interable类在collections(集合)模块中，使用时声明 from collections import interable]</li>
<li>写法<pre><code>for x in L:
    xxx
</code></pre><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3></li>
<li>注意在循环外初始化控制变量；</li>
<li><span style="color:red">python中无++运算符</span>;</li>
<li>break跳出循环</li>
<li>continue 跳过当次循环体之后的内容，直接进入下一次循环。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;if分支语句&quot;&gt;&lt;a href=&quot;#if分支语句&quot; class=&quot;headerlink&quot; title=&quot;if分支语句&quot;&gt;&lt;/a&gt;if分支语句&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;注意Python代码的缩进规则。&lt;/span&gt;具
    
    </summary>
    
      <category term="后端学习" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/"/>
    
      <category term="基本语法" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://zhangyan123.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Py有序集合类型</title>
    <link href="http://zhangyan123.github.io/2018/01/14/Py%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
    <id>http://zhangyan123.github.io/2018/01/14/Py有序集合类型/</id>
    <published>2018-01-14T12:20:20.000Z</published>
    <updated>2018-01-15T12:30:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="List（可变）"><a href="#List（可变）" class="headerlink" title="List（可变）"></a>List（可变）</h1><p>常用方法参数与返回值表格：<br><code>L=[3,4,5]</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">append</td>
<td style="text-align:left">L.append(ele)</td>
<td style="text-align:left">None</td>
</tr>
<tr>
<td style="text-align:left">insert</td>
<td style="text-align:left">L.insert(index,ele)</td>
<td style="text-align:left">None</td>
</tr>
<tr>
<td style="text-align:left">pop</td>
<td style="text-align:left">L.pop([index])</td>
<td style="text-align:left">removedValue</td>
</tr>
</tbody>
</table>
<ul>
<li>可以使用L[i]赋值方式更新原有元素，但不能用此方法增加新元素，会报outof range的错误，增加新元素使用append或者insert方法</li>
</ul>
<h1 id="Tuple（不可变）"><a href="#Tuple（不可变）" class="headerlink" title="Tuple（不可变）"></a>Tuple（不可变）</h1><p><code>T =(3,4,5)</code></p>
<ul>
<li>T一旦被创建就不可变；</li>
<li>只有一个元素的tuple写法 <code>t = (3,)</code>;</li>
<li><p style="color:red">tuple中元素若为可变对象，如list或dict，set,则tuple仍有不确定因素，需格外注意</p></li>
<li>tuple在python中有非常重要的地位<ul>
<li>多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</li>
<li>可变参数*args也是，在函数内部声明args局部变量存储了输入参数组成的tuple实例。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;List（可变）&quot;&gt;&lt;a href=&quot;#List（可变）&quot; class=&quot;headerlink&quot; title=&quot;List（可变）&quot;&gt;&lt;/a&gt;List（可变）&lt;/h1&gt;&lt;p&gt;常用方法参数与返回值表格：&lt;br&gt;&lt;code&gt;L=[3,4,5]&lt;/code&gt;&lt;/p&gt;
&lt;t
    
    </summary>
    
      <category term="后端学习" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/"/>
    
      <category term="基本语法" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://zhangyan123.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Py基本数据类型</title>
    <link href="http://zhangyan123.github.io/2018/01/13/Py%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://zhangyan123.github.io/2018/01/13/Py基本数据类型/</id>
    <published>2018-01-13T12:20:13.000Z</published>
    <updated>2018-01-13T13:52:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p><code>#</code> 后面跟的语句会被注释掉</p>
<p>#变量</p>
<ul>
<li>变量名必须为非保留字标识符：变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头；</li>
<li>声明变量不需要关键字 eg: <code>name_2 = &#39;Zhangyan&#39;</code>;</li>
<li>Python 与JS一样都是弱类型语言；</li>
<li>变量存储的都是对象的地址，Python中的数据类型皆为对象    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = &apos;ABC&apos;</div><div class="line">b = a</div><div class="line">a = &apos;XYZ&apos;</div><div class="line">print b</div><div class="line"># &apos;ABC&apos;</div></pre></td></tr></table></figure>
<h1 id="Python中5种基本数据类型"><a href="#Python中5种基本数据类型" class="headerlink" title="Python中5种基本数据类型"></a>Python中5种基本数据类型</h1><table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">input</th>
<th style="text-align:left">output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">整型</td>
<td style="text-align:left"><code>type(2)</code></td>
<td style="text-align:left"><code>&lt;class &#39;int&#39;&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">浮点型</td>
<td style="text-align:left"><code>type(3.5)</code></td>
<td style="text-align:left"><code>&lt;class &#39;float&#39;&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">字符串</td>
<td style="text-align:left"><code>type(&#39;rfkdjsl&#39;)</code></td>
<td style="text-align:left"><code>&lt;class &#39;str&#39;&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">布尔型</td>
<td style="text-align:left"><code>type(True)</code></td>
<td style="text-align:left"><code>&lt;class &#39;bool&#39;&gt;</code></td>
</tr>
<tr>
<td style="text-align:left">空型</td>
<td style="text-align:left"><code>type(None)</code></td>
<td style="text-align:left"><code>&lt;class &#39;NoneType&#39;&gt;</code></td>
</tr>
</tbody>
</table>
<h1 id="raw字符串与多行字符串"><a href="#raw字符串与多行字符串" class="headerlink" title="raw字符串与多行字符串"></a>raw字符串与多行字符串</h1><ul>
<li>当打印字符串时需要对字符串中有特殊意义的字符加<code>\</code>转义，eg<code>\&#39;&#39;</code><br>为了减少添加大量转义字符的麻烦，python提供了raw字符串，<code>r&#39;...&#39;</code>对其中的字符串保留原样，不采用特殊意义;</li>
<li>多行字符串需要在每行结尾添加<code>\n</code>，为减少这个麻烦，python提供多行字符串语法<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>;</li>
<li>常用<code>r&#39;&#39;&#39;...&#39;&#39;&#39;</code>输出多行raw字符串。</li>
</ul>
<h1 id="可能出现的编码问题"><a href="#可能出现的编码问题" class="headerlink" title="可能出现的编码问题"></a>可能出现的编码问题</h1><p>如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释<br><code># -*- coding: utf-8 -*-</code></p>
<h1 id="布尔值三中逻辑运算符就是对应英文单词"><a href="#布尔值三中逻辑运算符就是对应英文单词" class="headerlink" title="布尔值三中逻辑运算符就是对应英文单词"></a>布尔值三中逻辑运算符就是对应英文单词</h1><ul>
<li>与运算 <code>and</code>;</li>
<li>或运算 <code>or</code>;</li>
<li>非运算 <code>not</code>。</li>
<li><p style="color:red">使用时记得巧用短路原理</p><p></p></li>
</ul>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul>
<li><p>int(arg1[,base]),其中arg1可以是数字或字符串：</p>
<ul>
<li>数字可以是整数或浮点数表示取整； </li>
<li>当arg1为字符串时，必须为只包含数字的字符串，若有非数字字符则报【语义非法】ValueError,第一个参数为数值字符串时，第二个可选参数base为数值字符串整数的基，例：int(‘0xff’,16) #255</li>
</ul>
</li>
<li><p>long(x [,base ])        将x转换为一个长整数，详情类比int() </p>
</li>
<li>float(x )               将x转换到一个浮点数  </li>
<li>complex(real [,imag ])  创建一个复数  </li>
<li>str(x )                 将对象 x 转换为字符串  </li>
<li>repr(x )                将对象 x 转换为表达式字符串  </li>
<li>eval(str )              用来计算在字符串中的有效Python表达式,并返回一个对象  </li>
<li>tuple(s )               将序列 s 转换为一个元组  </li>
<li>list(s )                将序列 s 转换为一个列表  </li>
<li>chr(x )                 将一个整数转换为一个字符  </li>
<li>unichr(x )              将一个整数转换为Unicode字符  </li>
<li>ord(x )                 将一个字符转换为它的整数值  </li>
<li>hex(x )                 将一个整数转换为一个十六进制字符串  </li>
<li>oct(x )                 将一个整数转换为一个八进制字符串 </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h1&gt;&lt;p&gt;&lt;code&gt;#&lt;/code&gt; 后面跟的语句会被注释掉&lt;/p&gt;
&lt;p&gt;#变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量名必须为非保留字标识符：变量名必须
    
    </summary>
    
      <category term="后端学习" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/"/>
    
      <category term="基本语法" scheme="http://zhangyan123.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://zhangyan123.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>实现合理的跨域请求</title>
    <link href="http://zhangyan123.github.io/2017/08/27/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    <id>http://zhangyan123.github.io/2017/08/27/跨域资源共享/</id>
    <published>2017-08-27T08:30:00.000Z</published>
    <updated>2017-08-27T09:19:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原内容已删除，待补充与更新。。。"><a href="#原内容已删除，待补充与更新。。。" class="headerlink" title="原内容已删除，待补充与更新。。。"></a>原内容已删除，待补充与更新。。。</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原内容已删除，待补充与更新。。。&quot;&gt;&lt;a href=&quot;#原内容已删除，待补充与更新。。。&quot; class=&quot;headerlink&quot; title=&quot;原内容已删除，待补充与更新。。。&quot;&gt;&lt;/a&gt;原内容已删除，待补充与更新。。。&lt;/h1&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="问题及解决方案" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="安全问题" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="javaScript" scheme="http://zhangyan123.github.io/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>移动页面点击击穿问题</title>
    <link href="http://zhangyan123.github.io/2017/08/27/%E7%A7%BB%E5%8A%A8%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BB%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/"/>
    <id>http://zhangyan123.github.io/2017/08/27/移动页面点击击穿问题/</id>
    <published>2017-08-27T06:50:05.000Z</published>
    <updated>2017-08-27T13:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在移动端，click 事件有 300ms 的延迟，当 touchend 事件把上层元素隐藏之后，隔了300ms，浏览器触发了 click 事件，但是此时上层元素不见了，所以该事件被派发到了下层元素身上。如果下层对应的元素是一个链接，那页面就会意外地跳转，如果下层元素绑定了其他事件，此时更会有出乎意料的事情发生。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>   我们项目当中使用的antd推荐的Fastclick插件,意图解决300ms点击延迟问题，但实际开发当中，发现仍然存在点击穿透的情况（遮罩上方选择学校，遮罩消失之后对应下方的书籍卡片被意外点击，并展示了书籍中的乐谱信息。。。满眼的列表项），起初为了尽快解决问题，在遮罩下方又加了一层透明遮罩绑定click事件（点击消失）当肉盾，事后整理如下：</p>
<ul>
<li>fastclick使用touchend事件模拟click触发，并将真正的click事件屏蔽掉，但在某些（Android）手机上仍然存在不能屏蔽原生click事件的bug，造成点击事件触发两次的问题。</li>
<li><p>跨页穿透问题解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#preventClick &#123; width:100%; height:100%; position:absolute; z-index:1000; top:0; left:0; &#125;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;preventClick&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">function onDeviceReady() &#123;</div><div class="line">    setTimeout(function()&#123; $(&apos;#preventClick&apos;).hide(); &#125;, 300);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>本页穿透解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#preventClick &#123; width:100%; height:100%; position:absolute; z-index:999; top:0; left:0; &#125;</div><div class="line">&lt;container&gt;</div><div class="line">    &lt;div class=&apos;mask&apos;&gt;&lt;/div&gt;</div><div class="line">    &lt;div id=&quot;preventClick&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/container&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  document.getElementById(&apos;preventClick&apos;).onclick=function(e)&#123;</div><div class="line">    e.target.style.display=&quot;none&quot;;</div><div class="line">  &#125;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>由于穿透事件是click延迟造成的，只要将click事件用touch或者tap（由Zepto或KISSY库提供，同样由touch模拟出来的。）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>用户碰触移动页面之后，需要等待一段时间来判断是不是双击（double tap）动作（双击放大），而不是立即响应单击click，等待的这段时间大约是300ms，因此移动端click有300ms延迟，较好解决方法是使用touchend替换click事件，但注意在手势检测中屏蔽掉对以上模拟的影响。</p>
<h1 id="知识点补充："><a href="#知识点补充：" class="headerlink" title="知识点补充："></a>知识点补充：</h1><ul>
<li>pointer-events:none；由CSS3提出，不只是禁用链接hover，打开链接等效果，是真实意义上的将onlick事件去掉了，注意该样式只禁用了鼠标事件，对应的键盘事件并没有被禁用（tab选中，Enter提交等）。</li>
<li><p>PC网页上的大部分操作都是用鼠标的，即响应的是鼠标事件，包括mousedown、mouseup、mousemove和click事件。一次点击行为，可被拆解成：mousedown -&gt; mouseup -&gt; click 三步。</p>
</li>
<li><p>手机上没有鼠标，所以就用触摸事件去实现类似的功能。touch事件包含touchstart、touchmove、touchend，注意手机上并没有tap事件。手指触发触摸事件的过程为：touchstart -&gt; touchmove -&gt; touchend -&gt;300ms-&gt;click。</p>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;在移动端，click 事件有 300ms 的延迟，当 touchend 事件把上层元素隐藏之后，隔了300ms，浏览器触发了 click 事
    
    </summary>
    
      <category term="前端开发" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="问题及解决方案" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="移动开发问题" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="javaScript" scheme="http://zhangyan123.github.io/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://zhangyan123.github.io/2017/08/16/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhangyan123.github.io/2017/08/16/归并排序/</id>
    <published>2017-08-16T08:20:02.000Z</published>
    <updated>2017-08-16T08:37:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>#步骤拆解：</p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<h1 id="简单实现："><a href="#简单实现：" class="headerlink" title="简单实现："></a>简单实现：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function mergeSort(arr) &#123;</div><div class="line">    var len = arr.length;</div><div class="line">    if (len &lt; 2) &#123;</div><div class="line">        return arr;</div><div class="line">    &#125; </div><div class="line">    var middle = Math.floor(len / 2),</div><div class="line">        left = arr.slice(0, middle),</div><div class="line">        right = arr.slice(middle);</div><div class="line">    return merge(mergeSort(left), mergeSort(right));</div><div class="line"></div><div class="line">&#125;</div><div class="line">function merge(left, right) &#123;</div><div class="line">    var result = [];</div><div class="line">    console.time(&apos;归并排序耗时&apos;);</div><div class="line">    while (left.length &amp;&amp; right.length) &#123;</div><div class="line">        if (left[0] &lt; right[0]) &#123;</div><div class="line">            result.push(left.shift());</div><div class="line">        &#125; else &#123;</div><div class="line">            result.push(right.shift());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while (left.length) &#123;</div><div class="line">        result.push(left.shift());</div><div class="line">    &#125;</div><div class="line">    while (right.length) &#123;</div><div class="line">        result.push(right.shift());</div><div class="line">    &#125;</div><div class="line">    console.timeEnd(&apos;归并排序耗时&apos;);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#小结：<br>选择排序时间复杂度为O(n^2),空间复杂度为O(1)，稳定</p>
<h1 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h1><div style="display:inline-block;"><img src="/images/mergesort.gif" alt="myBlog"></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#步骤拆解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把长度为n的输入序列分成两个长度为n/2的子序列；&lt;/li&gt;
&lt;li&gt;对这两个子序列分别采用归并排序；&lt;/li&gt;
&lt;li&gt;将两个排序好的子序列合并成一个最终的排序序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;简单实现：&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="笔试准备" scheme="http://zhangyan123.github.io/categories/%E7%AC%94%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
      <category term="基本算法" scheme="http://zhangyan123.github.io/categories/%E7%AC%94%E8%AF%95%E5%87%86%E5%A4%87/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔试" scheme="http://zhangyan123.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>选择排序</title>
    <link href="http://zhangyan123.github.io/2017/08/16/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhangyan123.github.io/2017/08/16/选择排序/</id>
    <published>2017-08-16T08:10:02.000Z</published>
    <updated>2017-08-16T08:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>#步骤拆解：</p>
<ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，</li>
<li>然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾（每趟遍历起始位置向后偏移一位）。以此类推，直到所有元素均排序完毕。</li>
<li>使用与数据规模较小的数组。</li>
</ul>
<h1 id="简单实现："><a href="#简单实现：" class="headerlink" title="简单实现："></a>简单实现：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function selectionSort(arr) &#123;</div><div class="line">    var length = arr.length;</div><div class="line">    var minindex, temp;</div><div class="line">    console.time(&apos;选择排序耗时&apos;);</div><div class="line">    for (var i = 0; i &lt; length; i++) &#123;</div><div class="line">        minindex = i;</div><div class="line">        for (var j = i + 1; j &lt; length; j++) &#123;//从未排序的子数组中找到最小数值的角标</div><div class="line">            if (arr[j] &lt; arr[minindex]) &#123;</div><div class="line">                minindex = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp= arr[minindex];//将最小数与</div><div class="line">        arr[minindex] = arr[i];</div><div class="line">        arr[i] = temp;</div><div class="line">    &#125;</div><div class="line">    console.timeEnd(&apos;选择排序耗时&apos;);</div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#小结：<br>归并排序时间复杂度为O(nlogn),空间复杂度为O(n)，不稳定</p>
<h1 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h1><div style="display:inline-block;"><img src="/images/selectionsort.gif" alt="myBlog"></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#步骤拆解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，&lt;/li&gt;
&lt;li&gt;然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾（每趟遍历起始位置向后偏移一位）。以此类推，直到所有元素均排序完毕。&lt;/li
    
    </summary>
    
      <category term="笔试准备" scheme="http://zhangyan123.github.io/categories/%E7%AC%94%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
      <category term="基本算法" scheme="http://zhangyan123.github.io/categories/%E7%AC%94%E8%AF%95%E5%87%86%E5%A4%87/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔试" scheme="http://zhangyan123.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://zhangyan123.github.io/2017/08/16/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhangyan123.github.io/2017/08/16/插入排序/</id>
    <published>2017-08-16T08:00:02.000Z</published>
    <updated>2017-08-16T08:36:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>#步骤拆解：</p>
<p>插入排序的思想类似于斗地主时候一边抓牌一边插进已有牌的过程</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2-5.</li>
</ol>
<h1 id="简单实现："><a href="#简单实现：" class="headerlink" title="简单实现："></a>简单实现：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function insertionSort(arr) &#123;</div><div class="line">    console.time(&apos;插入排序耗时&apos;);</div><div class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">        var key = arr[i];//保存i位置的数值</div><div class="line">        for (var j = i -1; j &gt; 0; j--) &#123;//j用于确定已排序数组的末端，可见第一次赋值操作就将arr[i]覆盖掉了，因此之前的保留是必要的，此后的判断也应使用保留值</div><div class="line">            if (arr[j] &gt; key) &#123;</div><div class="line">                arr[j+1] = arr[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        arr[j+1] = key;//将本轮需插入的值插入到已排序数组中</div><div class="line">    &#125;</div><div class="line">    console.timeEnd(&apos;插入排序耗时&apos;);</div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#小结：<br>插入排序时间复杂度为O(n)-O(n^2),空间复杂度为O(1),稳定</p>
<h1 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h1><div style="display:inline-block;"><img src="/images/insertionsort.gif" alt="myBlog"></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#步骤拆解：&lt;/p&gt;
&lt;p&gt;插入排序的思想类似于斗地主时候一边抓牌一边插进已有牌的过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从第一个元素开始，该元素可以认为已经被排序；&lt;/li&gt;
&lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描；&lt;/li&gt;
&lt;li&gt;如果该元素（已排序）大于
    
    </summary>
    
      <category term="笔试准备" scheme="http://zhangyan123.github.io/categories/%E7%AC%94%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
      <category term="基本算法" scheme="http://zhangyan123.github.io/categories/%E7%AC%94%E8%AF%95%E5%87%86%E5%A4%87/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔试" scheme="http://zhangyan123.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://zhangyan123.github.io/2017/08/16/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhangyan123.github.io/2017/08/16/冒泡排序/</id>
    <published>2017-08-16T07:50:01.000Z</published>
    <updated>2017-08-16T08:36:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>#步骤拆解：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到未完成排序的最后一对，这样在数组的顶部自动生成一个不断加长的有序数列；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复1-3步，直到排序完成。</li>
</ul>
<h1 id="简单实现："><a href="#简单实现：" class="headerlink" title="简单实现："></a>简单实现：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function bubbleSort(arr)&#123;</div><div class="line">    var i = arr.length-1;//需要遍历的元素是从第一个到倒数第二个，因为每次比较的是arr[i]与arr[i+1]</div><div class="line">    console.time(&apos;冒泡排序&apos;);</div><div class="line">    while(i&gt;0)&#123;</div><div class="line">        var pos = 0;//每次遍历重新计算最后交换数据的位置</div><div class="line">        for(var j=0;j&lt;i;j++)&#123;</div><div class="line">            if(arr[j]&gt;arr[j+1])&#123;</div><div class="line">                pos =j;</div><div class="line">                arr[j]^=arr[j+1];//亦或可以交换两个不同值的变量的值，如果值相同交换后变成0，需要格外小心。</div><div class="line">                arr[j+1]^=arr[j];</div><div class="line">                arr[j]^=arr[j+1];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        i=pos;//每次遍历后将下次遍历的终点设置为数组顶部有序数列的开始位置（有序数列不参与下次遍历和交换）</div><div class="line">    &#125;</div><div class="line">     console.timeEnd(&apos;冒泡排序&apos;);   </div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#小结：<br>冒泡排序时间复杂度为O(n)-O(n^2),空间复杂度为O(1),稳定</p>
<h1 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h1><div style="display:inline-block;"><img src="/images/bubblesort.gif" alt="myBlog"></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#步骤拆解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换它们两个；&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到未完成排序的最后一对，这样在数组的顶部自动生成一个不断加长的有序数列；&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步
    
    </summary>
    
      <category term="笔试准备" scheme="http://zhangyan123.github.io/categories/%E7%AC%94%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
      <category term="基本算法" scheme="http://zhangyan123.github.io/categories/%E7%AC%94%E8%AF%95%E5%87%86%E5%A4%87/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔试" scheme="http://zhangyan123.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://zhangyan123.github.io/2017/08/11/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://zhangyan123.github.io/2017/08/11/快速排序/</id>
    <published>2017-08-11T07:50:05.000Z</published>
    <updated>2017-08-16T08:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单实现："><a href="#简单实现：" class="headerlink" title="简单实现："></a>简单实现：</h1><p>注：快排的时间复杂度为O(nlgn)~O(n^2) ,由于使用递归调用栈空间复杂度为O(lgn),快排中相等数值排序之后前后位置可能发生变化，因此为非稳定排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function quicksort(arr) &#123;</div><div class="line">    if (arr.length &lt;= 1) &#123;</div><div class="line">        return arr;</div><div class="line">    &#125; else &#123;</div><div class="line">        var key = Math.floor(arr.length / 2), left = [], right = [];</div><div class="line">        var key = arr.splice(key, 1)[0];</div><div class="line">        for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">            if (arr[i] &lt; key) &#123;</div><div class="line">                left.push(arr[i]);</div><div class="line">            &#125; else &#123;</div><div class="line">                right.push(arr[i]);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return quicksort(left).concat([key], quicksort(right));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><p>它是图灵奖得主C. A. R. Hoare（1934–）于1960时提出来的。<br>排序的思路分为三步：  </p>
<ul>
<li>选择基准值；</li>
<li>遍历整个数组，小于基准值的数放在基准左边，否则放在基准右边；</li>
<li>左右两边的子集进一步分别进行以上两步，直到所有子集数组中只有一个数字为止。  </li>
</ul>
<p>上例中为方便起见选取了数据的中间值为基准，下图为网上下载图片，可见到基准值从左到右依次选择，个人还是觉得选择中间值更具有普遍意义，更易理解。</p>
<h1 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h1><div style="display:inline-block;"><img src="/images/quicksort.gif" alt="myBlog"></div>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单实现：&quot;&gt;&lt;a href=&quot;#简单实现：&quot; class=&quot;headerlink&quot; title=&quot;简单实现：&quot;&gt;&lt;/a&gt;简单实现：&lt;/h1&gt;&lt;p&gt;注：快排的时间复杂度为O(nlgn)~O(n^2) ,由于使用递归调用栈空间复杂度为O(lgn),快排中相等数值排序
    
    </summary>
    
      <category term="笔试准备" scheme="http://zhangyan123.github.io/categories/%E7%AC%94%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
      <category term="基本算法" scheme="http://zhangyan123.github.io/categories/%E7%AC%94%E8%AF%95%E5%87%86%E5%A4%87/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔试" scheme="http://zhangyan123.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Redux使用篇</title>
    <link href="http://zhangyan123.github.io/2017/08/02/%E7%90%86%E8%A7%A3redux%E8%A1%8C%E4%B8%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://zhangyan123.github.io/2017/08/02/理解redux行为（一）/</id>
    <published>2017-08-02T08:50:05.000Z</published>
    <updated>2017-08-16T09:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便在问题中总结提升，特辟【问题与解决】类目，惟愿从哪里跌倒，就不再摔进去。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li>reducer函数中判断分支复杂不易管理与阅读</li>
<li>创建store时传入一个reducer意味着每一个reducer都需要一个store管理数据，后期store维护相当混乱<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1></li>
<li>通过combineReducers将多个reducer合并成一个rootReducer，从而创建唯一的store管理众多action请求</li>
<li>将一种类型的actionCreators（eq:用户登录状态login、logout）放在一个文件当中，导出集合</li>
<li>将每一份actionCreators 文件对应的处理函数封装在Handlers对象里，触发action时检测action.type符合Handlers中的哪一项，便执行对应的函数体。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  以上解决方案在项目中得到了实践，还包括异步注入reducer等方案，为全局状态管理提供了清晰的思路，后续文章逐项具体讲解（记得带图）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便在问题中总结提升，特辟【问题与解决】类目，惟愿从哪里跌倒，就不再摔进去。&lt;/p&gt;
&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;reducer函数中判断分支复杂
    
    </summary>
    
      <category term="前端开发" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="问题及解决方案" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
      <category term="React使用" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/React%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="javaScript" scheme="http://zhangyan123.github.io/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>闭包应用场景</title>
    <link href="http://zhangyan123.github.io/2017/03/10/%E9%97%AD%E5%8C%85%E5%BA%94%E7%94%A8%EF%BC%881%EF%BC%89/"/>
    <id>http://zhangyan123.github.io/2017/03/10/闭包应用（1）/</id>
    <published>2017-03-10T08:46:04.000Z</published>
    <updated>2017-08-16T09:09:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS闭包在开发实战中的应用"><a href="#JS闭包在开发实战中的应用" class="headerlink" title="JS闭包在开发实战中的应用"></a>JS闭包在开发实战中的应用</h1><p>函数内创建内部函数并将内部函数赋值给外部变量情况(没有被返回的内部函数[[Scopes]]同样指向外层函数的作用域链，单独说闭包时为因为其强大的灵活性)，外层函数执行结束后外部变量所指向的函数对象[[Scopes]]属性中包含了外部函数中执行产生的局部值。须知道函数的作用域实在创建时候确定的，this值是在运行时候才确定的。<br>都说闭包如此灵活，强大，我想知道它究竟有什么用处</p>
<ul>
<li>对象的构建<br>为对象设置私有变量、私有方法（在构造函数上建特权方法访问局部变量）或静态变量和方法(在原型上建公有特权方法访问构造函数上的局部变量)</li>
<li>事件的回调函数<br>在回调函数中仍然可以访问到外层同步函数中的参数，变量或函数</li>
<li>偏函数（柯里化）<br><code>add =  num1=&gt; num2=&gt; num1+num2;</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS闭包在开发实战中的应用&quot;&gt;&lt;a href=&quot;#JS闭包在开发实战中的应用&quot; class=&quot;headerlink&quot; title=&quot;JS闭包在开发实战中的应用&quot;&gt;&lt;/a&gt;JS闭包在开发实战中的应用&lt;/h1&gt;&lt;p&gt;函数内创建内部函数并将内部函数赋值给外部变量情况(没
    
    </summary>
    
      <category term="前端开发" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaScript" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javaScript/"/>
    
      <category term="闭包" scheme="http://zhangyan123.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/javaScript/%E9%97%AD%E5%8C%85/"/>
    
    
      <category term="执行环境与作用域" scheme="http://zhangyan123.github.io/tags/%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
</feed>
