<?xml version="1.0" encoding="utf-8"?>
<search>
    
    
    <entry>
        <title><![CDATA[策略模式在前端开发中的应用]]></title>
        <url>http://zhangyan123.github.io/2016/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%882%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的：JS闭包在开发实战中的应用"><a href="#你应该知道的：JS闭包在开发实战中的应用" class="headerlink" title="你应该知道的：JS闭包在开发实战中的应用"></a>你应该知道的：JS闭包在开发实战中的应用</h1>]]></content>
        
        <categories>
            
            <category> 设计模式 </category>
            
            <category> 策略模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[剖析闭包的战场]]></title>
        <url>http://zhangyan123.github.io/2016/10/17/%E9%97%AD%E5%8C%85%E5%BA%94%E7%94%A8%EF%BC%881%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的：JS闭包在开发实战中的应用"><a href="#你应该知道的：JS闭包在开发实战中的应用" class="headerlink" title="你应该知道的：JS闭包在开发实战中的应用"></a>你应该知道的：JS闭包在开发实战中的应用</h1>]]></content>
        
        <categories>
            
            <category> 前端开发 </category>
            
            <category> javaScript </category>
            
            <category> 闭包 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[观察者模式在前端开发中的应用]]></title>
        <url>http://zhangyan123.github.io/2016/10/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%881%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的：前端开发中观察者模式实践"><a href="#你应该知道的：前端开发中观察者模式实践" class="headerlink" title="你应该知道的：前端开发中观察者模式实践"></a>你应该知道的：前端开发中观察者模式实践</h1>]]></content>
        
        <categories>
            
            <category> 设计模式 </category>
            
            <category> 观察者模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[正则表达式是提高效率的利器（一）]]></title>
        <url>http://zhangyan123.github.io/2016/10/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%881%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的：RegExp"><a href="#你应该知道的：RegExp" class="headerlink" title="你应该知道的：RegExp"></a>你应该知道的：RegExp</h1><p>对于正则表达式，不同的语言有着不同的实现（每种语言的正则表达式互相之间的关系类似方言，同理不同表达），js采用的是Perl5的语法。</p>
<ul>
<li>构造正则对象的方式：<ul>
<li>优选字面量方式：<code>var re = /^j.*t$/gim</code>     </li>
<li>构造器方式：<code>var re = RegExp(‘^j.*t$’,’gim’)</code></li>
</ul>
</li>
<li>正则对象的属性：<ul>
<li>global 全局检测，默认false;</li>
<li>ignoreCase  忽略大小写，默认false;</li>
<li>multiline 跨行搜索，默认false;</li>
<li>lastIndex 搜索开始位置索引值，默认0;</li>
<li>source 存储了正则对象的pattern<br>以上属性均在对象创建时设置，使用对象过程中不可修改（除了lastIndex）.</li>
</ul>
</li>
<li><p>应用正则对象的方法:</p>
<ul>
<li>test() 返回布尔值，被测字符串符合模式true</li>
<li>exec() 返回匹配到字符串组成的数据<br>以上为正则对象自带方法，下面总结字符串对象中应用正则对象的场景     </li>
<li>match() 返回匹配内容的数组</li>
<li>search() 返回第一个匹配内容所在的位置索引值</li>
<li><p>replace() 将匹配的文本替换为指定的字符串</p>
<ol>
<li><p>回调式替换     </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s.replace(&quot;/(.*)@(.*)\.(.*)/g&quot;,callback);</div><div class="line">  function callback(匹配到的内容(例子函数体内使用match表示)，模式分组匹配到的字符串组，匹配内容所在位置索引值，被搜索的字符串)&#123;</div><div class="line">    return &quot;_&quot;+match;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>(pattern)当匹配模式被放在括号中时，标明该匹配模式的匹配串是可获取的，这种模式成为捕获模式，使用<code>$1…$9</code>等参数来指代<br>(?:pattern)相对与捕获模式可以理解这种非捕获模式，捕获过程中直接跳过这些模式，eg:    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;regular expression&quot;.replace(&apos;/(?:r)(e)/g&apos;,&apos;$1$1&apos;);</div><div class="line">//&quot;eegular expeession&quot;匹配到了所有的‘re’并用ee替换,可见r没有被捕获进$1</div></pre></td></tr></table></figure>
</li>
</ol>
<p><div style="display:inline-block;"><img src="/images/replace.png" alt="myBlog">&lt;/div</div></p>
</li>
<li>split() 以模式匹配的内容为分隔点，将字符串分割为数组</li>
</ul>
</li>
</ul>
]]></content>
        
        <categories>
            
            <category> 正则表达式 </category>
            
            <category> 方法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[ES5新增常用特性]]></title>
        <url>http://zhangyan123.github.io/2016/10/12/JS%E5%8F%91%E5%B1%95%E5%8F%B2%EF%BC%881%EF%BC%89/</url>
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ECMAScript 5.1 (或仅 ES5) 是ECMAScript(基于JavaScript的规范)标准最新修正。 与HTML5规范进程本质类似，ES5通过对现有JavaScript方法添加语句和原生ECMAScript对象做合并实现标准化。ES5还引入了一个语法的严格变种，被称为”严格模式(strict mode)”。</p>
<p>本文介绍一些有用的改变和添加。</p>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>随着Opera 11.60的发布, 所有5大浏览器都支持ES5, 除了一些实现的bugs. 除非另有说明，本文中提到的的一切可以用在以下浏览器版本（或更高）：</p>
<ul>
<li>Opera 11.60</li>
<li>Internet Explorer 9*</li>
<li>Firefox 4</li>
<li>Safari 5.1**</li>
<li>Chrome 13</li>
<li>IE9不支持严格模式 — IE10 添加</li>
<li>Safari 5.1 仍不支持 Function.prototype.bind, 尽管 Function.prototype.bind现在已经被Webkit所支持。</li>
</ul>
<h2 id="ES5的严格模式"><a href="#ES5的严格模式" class="headerlink" title="ES5的严格模式"></a>ES5的严格模式</h2><p>严格模式给作者提供了选择一个限制性更强语言变种的方式——给作者提供额外的可靠性给用户提供额外的安全性。在JS文件或是函数的顶部添加”use strict”即可启用严格模式。因为”use strict”就是个字符串，因此其会被旧版浏览器安全地忽视。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">function strict()&#123;</div><div class="line">  &quot;use strict&quot;;</div><div class="line">  //...</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sloppy()&#123;</div><div class="line">  eval(&quot;window.foo = &apos;bar&apos;&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在严格模式下运行脚本，不少导致提醒或buggy行为的事情会抛出错误，例如：</p>
<p>未声明的变量赋值抛出一个ReferenceError, 而不是创建一个全局变量。<br>不止一次对对象字面量分配相同的属性会抛出SyntaxError.<br>使用with语句抛出SyntaxError.<br>MDSN的严格模式文章有个关于所有这些差异很有用的总结表格。</p>
<h2 id="新增JSON"><a href="#新增JSON" class="headerlink" title="新增JSON"></a>新增JSON</h2><p>ES5提供一个全局的JSON对象，用来序列化(JSON.stringify)和反序列化(JSON.parse)对象为JSON格式。</p>
<p>对于老的浏览器，可以考虑使用Douglas Crockford的json2.js, 可以让旧的浏览器实现同样的功能（原始支持功能测试后）。</p>
<p>JSON.parse(text [, reviver])</p>
<p>JSON.parse接受文本(JSON格式)并转换成一个ECMAScript值。该可选的reviver参数是有带有key和value两个参数的函数，其作用于结果——让过滤和转换返回值成为可能。</p>
<figure class="highlight plain"><figcaption><span>result = JSON.parse('&#123;"a": 1, "b": "2"&#125;');</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//Object</div><div class="line"> result.b</div><div class="line">//&quot;2&quot;</div></pre></td></tr></table></figure>
<p>如果我们想确保解析的值是个整数，我们可以使用reviver方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var result = JSON.parse(&apos;&#123;&quot;a&quot;: 1, &quot;b&quot;: &quot;2&quot;&#125;&apos;, function(key, value)&#123;</div><div class="line">  if (typeof value == &apos;string&apos;)&#123;</div><div class="line">    return parseInt(value);</div><div class="line">  &#125; else &#123;</div><div class="line">    return value; </div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">&gt;&gt; result.b</div><div class="line">2</div><div class="line">JSON.stringify(value [, replacer [, space]])</div></pre></td></tr></table></figure></p>
<p>JSON.stringify允许作者接受一个ECMAScript值然后转换成JSON格式的字符串。 在其最简单的形式中，JSON.stringify接受一个值返回一个字符串，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> var mike = JSON.stringify(&#123;mike: &quot;taylor&quot;&#125;)</div><div class="line">//undefined</div><div class="line"></div><div class="line">mike</div><div class="line">//&apos;&#123;&quot;mike&quot;: &quot;taylor&quot;&#125;&apos;</div><div class="line"></div><div class="line">typeof mike</div><div class="line">//&quot;string&quot;</div></pre></td></tr></table></figure></p>
<p>如果我们需要改变值字符串化的方式，或是对我们选择的提供过滤，我们可以将其传给replacer函数。例如，我们想过滤出即将被字符串化的对象中值为13的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var nums = &#123;</div><div class="line">  &quot;first&quot;: 7,</div><div class="line">  &quot;second&quot;: 14,</div><div class="line">  &quot;third&quot;: 13</div><div class="line">&#125;</div><div class="line"></div><div class="line">var luckyNums = JSON.stringify(nums, function(key, value)&#123;</div><div class="line">  if (value == 13) &#123;</div><div class="line">    return undefined;</div><div class="line">  &#125; else &#123;</div><div class="line">    return value;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">&gt;&gt; luckyNums</div><div class="line">&apos;&#123;&quot;first&quot;: 7, &quot;second&quot;: 14&#125;&apos;</div></pre></td></tr></table></figure></p>
<p>如果replacer方法返回undefined, 则键值对就不会包含在最终的JSON中。我们同样可以传递一个space参数以便获得返回结果的可读性帮助。space参数可以是个数字，表明了作缩进的JSON字符串或字符串每个水平上缩进的空格数。如果参数是个超过10的数值，或是超过10个字符的字符串，将导致取数值10或是截取前10个字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var luckyNums = JSON.stringify(nums, function(key, value) &#123;</div><div class="line">  if (value == 13) &#123;</div><div class="line">    return undefined;</div><div class="line">  &#125; else &#123;</div><div class="line">    return value;</div><div class="line">  &#125;</div><div class="line">&#125;, 2);</div><div class="line"></div><div class="line">&gt;&gt; luckyNums</div><div class="line">&apos;&#123;</div><div class="line">  &quot;first&quot;:7,</div><div class="line">  &quot;second&quot;:14</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure></p>
<h2 id="对象新增方法"><a href="#对象新增方法" class="headerlink" title="对象新增方法"></a>对象新增方法</h2><p>下面的方法是添加到Object上的构造器：</p>
<p>Object.getPrototypeOf<br>Object.getOwnPropertyDescriptor<br>Object.getOwnPropertyNames<br>Object.create<br>Object.defineProperty(定义属性描述)</p>
<ul>
<li>在ES3中，除了一些内置属性（例如Math.PI），对象的属性是可以在任何时候都进行增删改查的，在ES5中，这种原本内建属性才有的特权被普适话，ES5引入属性描述符的概念，我们可以通过它对定义的属性有更大的控制权。属性描述符是每个属性都具备的一个描述对象，是对象就可以有属性和方法，但属性描述符对象的成员是确定的，为避免歧义，我们可以叫这些成员为特性；</li>
<li>了解下属性描述符中的特性：<ul>
<li>value 存放属性值</li>
<li>writable  是否可写</li>
<li>enumberable 是否可枚举</li>
<li>configurable 是否可删除</li>
<li>set() 更新属性时调用</li>
<li>get() 获取属性时调用</li>
</ul>
</li>
<li><p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var person=&#123;&#125;;</div><div class="line">person.leds=2;</div></pre></td></tr></table></figure>
<p>以上ES3风格的代码等价为     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person=&#123;&#125;;</div><div class="line">Object.defineProperty(person,&quot;legs&quot;,&#123;</div><div class="line">  value:2,</div><div class="line">  writable:true,</div><div class="line">  configurable:true,</div><div class="line">  enumrable:true</div><div class="line"></div><div class="line">&#125;);如上所示，除了value默认为undefined其他特性均默认为false,这意味着，通过这种方式定义属性时需显示设定他们值为true。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Object.defineProperties<br>Object.seal<br>Object.freeze<br>Object.preventExtensions<br>Object.isSealed<br>Object.isFrozen<br>Object.isExtensible<br>Object.keys<br>这些新增的好处之一是对象的属性有了更多控制，例如哪些是允许被修改的，哪些是可以枚举的，哪些是可以删除的等。这个的实现通过程序访问对象的属性描述符(property descriptors). 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var cat = &#123;&#125;;</div><div class="line"></div><div class="line">Object.defineProperty(cat, &quot;name&quot;, &#123;</div><div class="line">  value: &quot;Maru&quot;,</div><div class="line">  writable: false,</div><div class="line">  enumerable: true,</div><div class="line">  configurable: false</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Object.defineProperty(cat, &quot;skill&quot;, &#123;</div><div class="line">  value: &quot;exploring boxes&quot;,</div><div class="line">  writable: true,</div><div class="line">  enumerable: true,</div><div class="line">  configurable: true</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>对于我们的cat对象, 其名字name不能被改变，但是会出现在for-in循环中。在其他方面，Maru擅长探索盒子(exploring boxes), 但是可以在将来改变，因为skill属性是writable和configurable的。</p>
<p>在之后的文章我们将详细探讨所有附加的对象。</p>
<h2 id="数组新增方法"><a href="#数组新增方法" class="headerlink" title="数组新增方法"></a>数组新增方法</h2><p>以下方法添加到了Arrayprototype对象上:<br>Array.prototype.indexOf<br>Array.prototype.lastIndexOf<br>Array.prototype.every<br>Array.prototype.some<br>Array.prototype.forEach<br>Array.prototype.map<br>Array.prototype.filter<br>Array.prototype.reduce<br>Array.prototype.reduceRight<br>关于ES5数组”extras” Dmitry Soshnikov写过一篇有深度的参考文章。</p>
<p>Dmitry的文章中有一个没有提到，就是Array.isArray, 正如你看到的，这厮直接写在了Array构造器上，而不是prototype对象上。Array.isArray会按照你所期待的那样去做 — 这是一个根据参数的[[Class]]内部属性是否是”Array”返回true或false.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Array.isArray(&quot;NO U&quot;)</div><div class="line">&gt;&gt; false</div><div class="line"></div><div class="line">Array.isArray([&quot;NO&quot;, &quot;U&quot;])</div><div class="line">&gt;&gt; true</div></pre></td></tr></table></figure></p>
<p>在ES3中，唯一可靠的确定一个值是数组的方式就是使用“the Miller Device”, 即比对一个数组其内在的[[Class]]属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Object.prototype.toString.apply(value) === &apos;[object Array]&apos;</div><div class="line">Function.prototype.bind(thisArg [, arg1 [, arg2, …]])</div><div class="line">Function.prototype.bind返回一个新的函数对象，该函数对象的this绑定到了thisArg参数上。从本质上讲，这允许你在其他对象链中执行一个函数。</div><div class="line"></div><div class="line">function locate()&#123;</div><div class="line">  console.log(this.location);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Maru(location)&#123;</div><div class="line">  this.location = location;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var kitty = new Maru(&quot;cardboard box&quot;);</div><div class="line"></div><div class="line">var locateMaru = locate.bind(kitty);</div><div class="line"></div><div class="line">locateMaru();</div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们将Maru对象的上下文应用在location函数中。因为location是个全局对象的属性，其this值就是全局对象(window)。在这种情况下，我们向上寻找cat, 并不是Location对象，因为我们可以通过绑定的总是kitty的this值创建一个新方法locateMaru.</p>
<h2 id="补充参考"><a href="#补充参考" class="headerlink" title="补充参考"></a>补充参考</h2><p>ECMAScript 5 对象和属性 by John Resig<br>理解JavaScript函数调用和”this” by Yehuda Katz<br>JavaScript严格模式 by Angus Croll<br>ECMA-262-5详细 介绍 by Dmitry Soshnikov<br>ECMAScript 5 兼容性表 by Juriy Zaytsev<br>本文许可自Creative Commons Attribution 3.0 Unported许可。</p>
<p>本文转载自张鑫旭-鑫空间-鑫生活<a href="http://www.zhangxinxu.com/wordpress/?p=2148" target="_blank" rel="external">http://www.zhangxinxu.com</a></p>
]]></content>
        
        <categories>
            
            <category> 前端开发 </category>
            
            <category> javaScript </category>
            
            <category> JS进步史 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[啃掉IE低版本这块硬骨头（二）]]></title>
        <url>http://zhangyan123.github.io/2016/10/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%882%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的：CSS浏览器兼容性处理"><a href="#你应该知道的：CSS浏览器兼容性处理" class="headerlink" title="你应该知道的：CSS浏览器兼容性处理"></a>你应该知道的：CSS浏览器兼容性处理</h1><p>一、document.formName.item(”itemName”) 问题 </p>
<p>问题说明：IE下，可以使用 document.formName.item(”itemName”) 或 document.formName.elements [“elementName”]；Firefox 下，只能使用document.formName.elements[“elementName”]。<br>解决方法：统一使用document.formName.elements[“elementName”]。 </p>
<p>二、集合类对象问题 </p>
<p>问题说明：IE下，可以使用 () 或 [] 获取集合类对象；Firefox下，只能使用 [ ]获取集合类对象。<br>解决方法：统一使用 [] 获取集合类对象。 </p>
<p>三、自定义属性问题 </p>
<p>问题说明：IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性；Firefox下，只能使用 getAttribute() 获取自定义属性。<br>解决方法：统一通过 getAttribute() 获取自定义属性。 </p>
<p>四、eval(”idName”)问题 </p>
<p>问题说明：IE下，可以使用 eval(”idName”) 或 getElementById(”idName”) 来取得 id 为 idName 的HTML对象；Firefox下，只能使用 getElementById(”idName”) 来取得 id 为 idName 的HTML对象。<br>解决方法：统一用 getElementById(”idName”) 来取得 id 为 idName 的HTML对象。 </p>
<p>五、变量名与某HTML对象ID相同的问题 </p>
<p>问题说明：IE下，HTML对象的ID可以作为 document 的下属对象变量名直接使用，Firefox下则不能；Firefox下，可以使用与HTML对象ID相同的变量名，IE下则不能。<br>解决方法：使用 document.getElementById(”idName”) 代替 document.idName。最好不要取HTML对象ID相同的变量名，以减少错误；在声明变量时，一律加上var关键字，以避免歧义。 </p>
<p>六、const问题 </p>
<p>问题说明：Firefox下，可以使用const关键字或var关键字来定义常量；IE下，只能使用var关键字来定义常量。<br>解决方法：统一使用var关键字来定义常量。 </p>
<p>七、input.type属性问题 </p>
<p>问题说明：IE下 input.type 属性为只读；但是Firefox下 input.type 属性为读写。<br>解决办法：不修改 input.type 属性。如果必须要修改，可以先隐藏原来的input，然后在同样的位置再插入一个新的input元素。 </p>
<p>八、window.event问题 </p>
<p>问题说明：window.event 只能在IE下运行，而不能在Firefox下运行，这是因为Firefox的event只能在事件发生的现场使用。<br>解决方法：在事件发生的函数上加上event参数，在函数体内(假设形参为evt)使用 var myEvent = evt?evt:(window.event?window.event:null)<br>示例： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; onclick=&quot;doSomething(event)&quot;/&gt; </div><div class="line">&lt;script language=&quot;javascript&quot;&gt; </div><div class="line">function doSomething(evt) &#123; </div><div class="line">var myEvent = evt?evt:(window.event?window.event:null) </div><div class="line">... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>九、event.x与event.y问题 </p>
<p>问题说明：IE下，even对象有x、y属性，但是没有pageX、pageY属性；Firefox下，even对象有pageX、pageY属性，但是没有x、y属性。<br>解决方法：var myX = event.x ? event.x : event.pageX; var myY = event.y ? event.y:event.pageY;<br>如果考虑第8条问题，就改用myEvent代替event即可。 </p>
<p>十、event.srcElement问题 </p>
<p>问题说明：IE下，even对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性。<br>解决方法：使用srcObj = event.srcElement ? event.srcElement : event.target;<br>如果考虑第8条问题，就改用myEvent代替event即可。 </p>
<p>十一、window.location.href问题 </p>
<p>问题说明：IE或者Firefox2.0.x下，可以使用window.location或window.location.href；Firefox1.5.x下，只能使用window.location。<br>解决方法：使用 window.location 来代替 window.location.href。当然也可以考虑使用 location.replace()方法。 </p>
<p>十二、模态和非模态窗口问题 </p>
<p>问题说明：IE下，可以通过showModalDialog和showModelessDialog打开模态和非模态窗口；Firefox下则不能。<br>解决方法：直接使用 window.open(pageURL,name,parameters) 方式打开新窗口。<br>如果需要将子窗口中的参数传递回父窗口，可以在子窗口中使用window.opener来访问父窗口。如果需要父窗口控制子窗口的话，使用 var subWindow = window.open(pageURL,name,parameters); 来获得新开的窗口对象。 </p>
<p>十三、frame和iframe问题 </p>
<p>以下面的frame为例： </p>
<p>(1)访问frame对象<br>IE：使用window.frameId或者window.frameName来访问这个frame对象；<br>Firefox：使用window.frameName来访问这个frame对象；<br>解决方法：统一使用 window.document.getElementById(”frameId”) 来访问这个frame对象；<br>(2)切换frame内容<br>在IE和Firefox中都可以使用 window.document.getElementById(”frameId”).src = “webjx.com.html”或 window.frameName.location = “webjx.com.html”来切换frame的内容；<br>如果需要将frame中的参数传回父窗口，可以在frame中使用parent关键字来访问父窗口。 </p>
<p>十四、body载入问题 </p>
<p>问题说明：Firefox的body对象在body标签没有被浏览器完全读入之前就存在；而IE的body对象则必须在body标签被浏览器完全读入之后才存在。<br>[注] 这个问题尚未实际验证，待验证后再来修改。<br>[注] 经验证，IE6、Opera9以及FireFox2中不存在上述问题，单纯的JS脚本可以访问在脚本之前已经载入的所有对象和元素，即使这个元素还没有载入完成。 </p>
<p>十五、事件委托方法 </p>
<p>问题说明：IE下，使用 <code>document.body.onload = inject;</code> 其中<code>function inject()</code>在这之前已被实现；在Firefox下，使用 <code>document.body.onload = inject()</code>;<br>解决方法：统一使用 <code>document.body.onload=new Function(&#39;inject()&#39;);</code>或者 <code>document.body.onload = function(){/* 这里是代码 */}</code><br>[注意] Function和function的区别 </p>
<p>十六、访问的父元素的区别 </p>
<p>问题说明：在IE下，使用 obj.parentElement 或 obj.parentNode 访问obj的父结点；在firefox下，使用 obj.parentNode 访问obj的父结点。<br>解决方法：因为firefox与IE都支持DOM，因此统一使用obj.parentNode 来访问obj的父结点。 </p>
<p>十七、innerText的问题. </p>
<p>问题说明：innerText在IE中能正常工作，但是innerText在FireFox中却不行。<br>解决方法：在非IE浏览器中使用textContent代替innerText。<br>示例： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(navigator.appName.indexOf(&quot;Explorer&quot;) &gt;-1)&#123; </div><div class="line">document.getElementById(&apos;element&apos;).innerText = &quot;my text&quot;; </div><div class="line">&#125; else&#123; </div><div class="line">document.getElementById(&apos;element&apos;).textContent = &quot;;my text&quot;; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[注] innerHTML 同时被ie、firefox等浏览器支持，其他的，如outerHTML等只被ie支持，最好不用。 </p>
<p>十八、Table操作问题 </p>
<p>问题说明：ie、firefox以及其它浏览器对于 table 标签的操作都各不相同，在ie中不允许对table和tr的innerHTML赋值，使用js增加一个tr时，使用appendChild方法也不管用。document.appendChild在往表里插入行时FIREFOX支持，IE不支持<br>解决办法：把行插入到TBODY中，不要直接插入到表<br>解决方法： </p>
<p>//向table追加一个空行： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var row = otable.insertRow(-1); </div><div class="line">var cell = document.createElement(&quot;td&quot;); </div><div class="line">cell.innerHTML = &quot;&quot;; </div><div class="line">cell.className = &quot;XXXX&quot;; </div><div class="line">row.appendChild(cell);</div></pre></td></tr></table></figure>
<p>[注] 建议使用JS框架集来操作table，如JQuery。 </p>
<p>十九、对象宽高赋值问题 </p>
<p>问题说明：FireFox中类似 obj.style.height = imgObj.height 的语句无效。<br>解决方法：统一使用 obj.style.height = imgObj.height + ‘px’; </p>
<p>二十、setAttribute(‘style’,’color:red;’)<br>FIREFOX支持(除了IE，现在所有浏览器都支持)，IE不支持<br>解决办法：不用setAttribute(‘style’,’color:red’)<br>而用object.style.cssText = ‘color:red;’(这写法也有例外)<br>最好的办法是上面种方法都用上，万无一失 </p>
<p>二一、类名设置<br>setAttribute(‘class’,’styleClass’)<br>FIREFOX支持，IE不支持(指定属性名为class，IE不会设置元素的class属性，相反只使用setAttribute时IE自动识CLASSNAME属性)<br>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setAttribute(&apos;class&apos;,&apos;styleClass&apos;) </div><div class="line"></div><div class="line">setAttribute(&apos;className&apos;,&apos;styleClass&apos;)</div></pre></td></tr></table></figure></p>
<p>或者直接 <code>object.className=&#39;styleClass&#39;</code>; </p>
<p>IE和FF都支持object.className。 </p>
<p>二二、用setAttribute设置事件<br><code>var obj = document.getElementById(&#39;objId&#39;)</code>;<br><code>obj.setAttribute(&#39;onclick&#39;,&#39;funcitonname();&#39;)</code>;<br>FIREFOX支持，IE不支持<br>解决办法：<br>IE中必须用点记法来引用所需的事件处理程序,并且要用赋予匿名函数<br>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var obj = document.getElementById(&apos;objId&apos;); </div><div class="line">obj.onclick=function()&#123;fucntionname();&#125;;</div></pre></td></tr></table></figure></p>
<p>这种方法所有浏览器都支持 </p>
<p>二三、建立单选钮<br>IE以外的浏览器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var rdo = document.createElement(&apos;input&apos;); </div><div class="line">rdo.setAttribute(&apos;type&apos;,&apos;radio&apos;); </div><div class="line">rdo.setAttribute(&apos;name&apos;,&apos;radiobtn&apos;); </div><div class="line">rdo.setAttribute(&apos;value&apos;,&apos;checked&apos;);</div></pre></td></tr></table></figure></p>
<p>IE:<br><code>var rdo =document.createElement(”&lt;input name=”radiobtn” type=”radio” value=”checked” /&gt;”);</code><br>解决办法：<br>这一点区别和前面的都不一样。这次完全不同，所以找不到共同的办法来解决，那么只有IF-ELSE了<br>万幸的是，IE可以识别出document的uniqueID属性，别的浏览器都不可以识别出这一属性。问题解决。</p>
]]></content>
        
        <categories>
            
            <category> 前端开发 </category>
            
            <category> 兼容性问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[啃掉IE低版本这块硬骨头（一）]]></title>
        <url>http://zhangyan123.github.io/2016/10/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%881%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的：JS浏览器兼容性处理"><a href="#你应该知道的：JS浏览器兼容性处理" class="headerlink" title="你应该知道的：JS浏览器兼容性处理"></a>你应该知道的：JS浏览器兼容性处理</h1><ul>
<li><p>兼容事件处理</p>
<blockquote>
<p>按照DOM Level2的建议，事件传播分三个阶段（现代浏览器统一实现了这三个阶段）：先是捕获标签，然后到达对象，再冒泡。document出发寻找到事件源之后再返回到document，但是实际捕获事件时我们使用冒泡机制，在<code>addEventListener()</code>方法中体现为第三个参数置为<code>false</code>。<br>由于绝大多数浏览器完全实现了DOM1标准,但事件方面的标准化是在DOM2中才完成的,导致IE9之前的版本与其他浏览器在这方面表现存在差异.      </p>
</blockquote>
<ul>
<li>IE9之前的事件监听<br>添加监听器：IE5开始使用attachEvent()方法，更早版本只能使用内嵌在html中的属性方法，eg:<code>element.onclick=function(){//这是事件处理器}</code></li>
<li>事件源 <code>srcElement</code></li>
<li>阻止冒泡 <code>cancelBubble=ture;</code>IE只支持冒泡机制</li>
<li>阻止默认行为 <code>returnValue=false;</code></li>
<li>取消事件监听 <code>detachEvent()</code>相对于现代浏览器中的<code>removeEventListener()</code><br>基于以上分析,整理跨浏览器事件处理器如下:     <pre>function callback(e){
var e=e||window.event;
var target=e.target||e.srcElement;
console.log(target.nodeName);
}
if(document.addEventListener){
document.addEventListener('click',callback,false);
}else if(document.attachEvent){
document.attachEvent('click',callback);
}else{
document.onclick=callback;
}</pre>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>异步请求<br>我们知道目前非常熟悉的Ajax是通过XMLHttpRequest对象来进行Http请求的，在IE7之前这个对象不存在，我们可以使用的类似对象是ActiveXobject,eq:<code>var xhr = new ActiveXobject(‘MSXML2.XMLHTTP.3.0’)</code>   参数中的字符串是一个版本标识符，实际上XHR对象有几个不同的版本，应该根据用户客户端对版本的支持情况创建不同的XHR对象.<br>根据以上分析编写异步请求AJAX工具集如下：     </p>
<pre>function request(url,message,callback()){
  var versions=[
    'MSXML2.XMLHTTP.3.0',
    'MSXML2.XMLHTTP',
    'Microsoft.XMLHTTP'
  ];
  var xhr;
  if(XHRHttpRequest){
    xhr=new XMLHttpRequest();
  }else{
    for(var i=0;i< versions.length;i++){
      try{
        xhr=new ActiveXobject(versions[i]);
        break;
      }catch(e){}
    }
  }
  xhr.onreadystatechange = (function(myxhr){
     return function(){
       if(myxhr.readyState ====4 && myxhr.status ===200){
         callback(xhr);
       }
     }
  })(xhr);
  xhr.open('post',url,true);//true代表了异步请求
  xhr.send(message);
}</pre> 
</li>
<li><p>css机制      </p>
<ul>
<li><p><strong> 兼容性处理要点 ：</strong></p>
<ol>
<li><p>DOCTYPE 影响 CSS 处理 </p>
</li>
<li><p>FF: 设置 padding 后， div 会增加 height 和 width， 但 IE 不会， 故需要用 !important 多设一个 height 和 width </p>
</li>
<li><p>FF: 支持 !important， IE 则忽略， 可用 !important 为 FF 特别设置样式 </p>
</li>
<li><p>div 的垂直居中问题: vertical-align:middle; 将行距增加到和整个DIV一样高 line-height:200px; 然后插入文字，就垂直居中了。缺点是要控制内容不要换行 </p>
</li>
<li><p>在mozilla firefox和IE中的BOX模型解释不一致导致相差2px解决方法： </p>
<p>div{margin:30px!important;margin:28px;} </p>
<p>注意这两个margin的顺序一定不能写反，!important这个属性IE不能识别，但别的浏览器可以识别。所以在IE下其实解释成这样： </p>
<p>div{maring:30px;margin:28px} </p>
<p>重复定义的话按照最后一个来执行，所以不可以只写margin:XXpx!important; </p>
</li>
</ol>
</li>
<li><p><strong>浏览器差异:</strong> </p>
<ol>
<li><p>ul和ol列表缩进问题 </p>
<p>消除ul、ol等列表的缩进时，样式应写成：list-style:none;margin:0px;padding:0px;<br>其中margin属性对IE有效，padding属性对FireFox有效。 </p>
<p>[注]经验证，在IE中，设置margin:0px可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置padding对样式没有影响；在 Firefox 中，设置margin:0px仅仅可以去除上下的空白，设置padding:0px后仅仅可以去掉左右缩进，还必须设置list- style:none才 能去除列表编号或圆点。也就是说，在IE中仅仅设置margin:0px即可达到最终效果，而在Firefox中必须同时设置margin:0px、 padding:0px以及list-style:none三项才能达到最终效果。 </p>
</li>
<li><p>CSS透明问题 </p>
<p>IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。<br>FF：opacity:0.6。<br>[注] 最好两个都写，并将opacity属性放在下面。 </p>
</li>
<li><p>CSS圆角问题 </p>
<p>IE：ie7以下版本不支持圆角。<br>FF： -moz-border-radius:4px，或者-moz-border-radius-topleft:4px;-moz- border- radius-topright:4px;-moz-border-radius-bottomleft:4px;-moz- border- radius- bottomright:4px;。<br>[注] 圆角问题是CSS中的经典问题，建议使用JQuery框架集来设置圆角，让这些复杂的问题留给别人去想吧。不过jQuery的圆角只看到支持整个区域的圆角，没有支持边框的圆角，不过这个边框的圆角可以通过一些简单的手段来实现，下次有机会介绍下。 </p>
</li>
<li><p>cursor:hand VS cursor:pointer </p>
<p>问题说明：firefox不支持hand，但ie支持pointer ，两者都是手形指示。<br>解决方法：统一使用pointer。 </p>
</li>
<li><p>字体大小定义不同 </p>
<p>对字体大小small的定义不同，Firefox中为13px，而IE中为16px，差别挺大。 </p>
<p>解决方法：使用指定的字体大小如14px。 </p>
<p>并列排列的多个元素（图片或者链接）的div和div之间，代码中的空格和回车在firefox中都会被忽略，而IE中却默认显示为空格（约3px）。 </p>
</li>
<li><p>CSS双线凹凸边框<br>IE：border:2px outset;。<br>FF： -moz-border-top-colors: #d4d0c8 white;-moz-border-left-colors: #d4d0c8 white;-moz-border-right-colors:#404040 #808080;-moz-border-bottom-colors:#404040 #808080; </p>
</li>
</ol>
</li>
<li><p><strong>浏览器bug:</strong> </p>
<ol>
<li><p>IE的双边距bug </p>
<p>设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。 </p>
<p>解决方案：在这个div里面加上display:inline; </p>
<p>例如： </p>
<p><code>&lt;#div id=”imfloat”&gt;</code> </p>
<p>相应的css为 </p>
<pre>#IamFloat{ 
float:left; 
margin:5px;/*IE下理解为10px*/ 
display:inline;/*IE下再理解为5px*/ 
} 
#IamFloat{ 
float:left; 
margin:5px;/*IE下理解为10px*/ 
display:inline;/*IE下再理解为5px*/ 
}</pre> 

<p>关于CSS中的问题实在太多了，甚至同样的CSS定义在不同的页面标准中的显示效果都是不一样的。一个合乎发展的建议是，页面采用标准XHTML标准编写，较少使用table，CSS定义尽量依照标准DOM，同时兼顾IE、Firefox、Opera等主流浏览器。很多情况下，FF和 Opera的CSS解释标准更贴近CSS标准，也更具有规范性。 </p>
</li>
<li><p>IE选择符空格BUG<br>一个空格也可以使样式失效。 </p>
<figure class="highlight plain"><figcaption><span>html PUBLIC "-//W3C//DTD XHTML 1.0</span><a href="/Transitional//EN//www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">">link</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;html xmlns=&quot;//www.w3.org/1999/xhtml&quot;&gt; </div><div class="line">&lt;head&gt; </div><div class="line">&lt;title&gt;&lt;/title&gt; </div><div class="line">&lt;style type=&quot;text/css&quot;&gt; </div><div class="line">&lt;!-- </div><div class="line">p&#123;font-size:12px;&#125; </div><div class="line">p:first-letter&#123;font-size:300%&#125; </div><div class="line">--&gt; </div><div class="line">&lt;/style&gt; </div><div class="line">&lt;/head&gt; </div><div class="line">&lt;body&gt; </div><div class="line">&lt;p&gt;对于世界而言，你是一个人；但是对于某个人，你是他的整个世界。纵然伤心，也不要愁眉不展，因为你不知是谁会爱上你的笑容。&lt;/p&gt; </div><div class="line">&lt;/body&gt; </div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>这段代码对<code>&lt;p&gt;</code>的首字符样式定义在IE6上看是没有效果的（IE7没测试），而在p:first-letter和{font-size:300%}加上空格，也就是p:first-letter {font-size:300%}后，显示就正常了。但是同样的代码，在FireFox下看是正常的。按道理说，p:first-letter{font-size:300%}的写法是没错的。那么问题出在哪里呢？答案是伪类中的连字符”-”。IE有个BUG，在处理伪类时，如果伪类的名称中带有连字符”-”，伪类名称后面就得跟一个空格，不然样式的定义就无效。而在FF中，加不加空格都可以正常处理。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>SSE(Server-sent Events)全新HTML5服务器推送事件技术，很明显只有现代浏览器才支持</p>
</li>
</ul>
]]></content>
        
        <categories>
            
            <category> 前端开发 </category>
            
            <category> 兼容性问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[浏览器环境]]></title>
        <url>http://zhangyan123.github.io/2016/10/08/javaScript%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的：浏览器环境"><a href="#你应该知道的：浏览器环境" class="headerlink" title="你应该知道的：浏览器环境"></a>你应该知道的：浏览器环境</h1><p><div style="display:inline-block;"><img src="/images/browser.png" alt="myBlog"></div><br>我们所说的内建方法与内建对象都可以理解为是全局对象的方法与成员。我们之后将全局对象称为head对象，举例子来说，node.js中的head对象是global对象，而浏览器中的head对象则是window，在console控制台中打印window可以看到全局的方法和属性,从图中可以看出window对象中会包含js原生对象，会包含DOM对象集合，同时还会包含一个可访问浏览器和计算机屏幕的对象集合。</p>
<p><strong> BOM能做哪些事情？</strong></p>
<ul>
<li>navigator属性：访问浏览器及其功能信息 eg:window.navigator.userAgent  </li>
<li>浏览器提供的控制台提供了遍历的对象检索功能，只需输入想要查询的对象便可以查看该对象全部的成员（对于本节内容有不详之处打印大发伺候）<code>console.dir()</code></li>
<li>location属性：用于存储当前载入页面URL信息的对象</li>
<li>history属性：属性允许用户以有限权限操作同一个浏览器回话（session）中已访问的页面。</li>
<li>frames属性为我们提供访问当前页所有框架的集合（一个类数组）</li>
<li>screen属性提供的是操作浏览器意外环境的句柄，可访问PC屏幕信息</li>
<li>BOM中的全局方法：<ul>
<li><pre>var win=window.open(URL,target,’width:123,height:123,resizable:yes,status:no’)//status</pre>用于设置状态栏可见性,open方法返回打开的窗口句柄win,关闭及操作时使用win为当前环境，eg:<code>win.close();</code></li>
<li>其他：moveTo()、moveBy()、alert()、prompt)()、confirm()</li>
<li>window.setTimeout()及setInterval()在程序中经常会出现始料未及的结果，首先这两个函数的参数环境是eval环境，在使用时延时应尽量封装好回调函数直接引用函数名，而非在参数中使用可执行的字符串。由于浏览器处理事件是有队列的，时延间隔到了回调函数也要按秩序进队等待被调用，因此导致的时间不准确是应该在预料之中的。</li>
</ul>
</li>
</ul>
]]></content>
        
        <categories>
            
            <category> 前端开发 </category>
            
            <category> javaScript </category>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[继承]]></title>
        <url>http://zhangyan123.github.io/2016/09/30/javaScript%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的：继承实现原理（从上到下由浅入深）"><a href="#你应该知道的：继承实现原理（从上到下由浅入深）" class="headerlink" title="你应该知道的：继承实现原理（从上到下由浅入深）"></a>你应该知道的：继承实现原理（从上到下由浅入深）</h1><ol>
<li><p>原型链继承模式<br><pre>function Shape(){</pre></p>
<pre><code>this.name=&apos;shape&apos;;
</code></pre><p>};</p>
<p>Shape.prototype.toString=function(){</p>
<pre><code>return this.name;
</code></pre><p>};</p>
<p>function Triangle(side,height){</p>
<pre><code>this.name=&apos;triangle&apos;;
this.side=side;
this.height=height;
</code></pre><p>}<br>Triangle.prototype.getArea=function(){</p>
<pre><code>return this.side*this.height/2;
</code></pre><p>};<br>Triangle.prototype=new Shape();<br>Triangle.prototype.constructor=Triangle;</p>
<blockquote>
<p>这种继承模式除了共享了“父类”（模拟说法，后面部分均直白表示为父类和子类）原型中的属性和方法之外，在原型上父类个性拥有的name属性，造成不必要资源浪费。<br><div style="display:inline-block;"><img src="/images/prototypeChain.png" alt="myBlog">&lt;/div</div></p>
</blockquote>
</li>
</ol>
<ol>
<li><p>临时构造器继承模式<br> 根据之前的分析知道<code>Triangle.prototype=new Shape();</code>语句造成了对多余父类属性的拷贝，为避免不共享的成员不被拷贝，我们可以启用临时“空”（只扮演传递父类原型指针的角色）构造器，并指定其原型属性指向父类原型。以此解决上述问题。</p>
  <pre>function Shape(){
    this.name='shape';
};

Shape.prototype.toString=function(){
    return this.name;
};

function Triangle(side,height){
    this.name='triangle';
    this.side=side;
    this.height=height;
}
 <strong>var F=function (){};
 F.prototype=Shape.prototype;
 Triangle.prototype=new F();
 Triangle.prototype.constructor=Triangle;
 </strong>

Triangle.prototype.getArea=function(){
    return this.side*this.height/2;
};</pre>进一步优化   

   <pre>function Shape(){
    this.name='shape';
}

Shape.prototype.toString=function(){
    return this.name;
};

function Triangle(side,height){
    this.name='triangle';
    this.side=side;
    this.height=height;
}
 <strong>var F=function (){
     this.getArea=function(){
         return this.side*this.height/2;
     };
 };
 F.prototype=Shape.prototype;
 Triangle.prototype=new F();
 Triangle.prototype.constructor=Triangle;
 </strong></pre>现在我们已经具备了一种比较良好的继承模式，既可以继承到父类的共享内容，又可以在子类中添加个性的成员而不对其父类造成影响，下面我们在核心功能的基础上增强继承的能力，增加子类访问父类成员的通道（模拟java super,super是js保留字故采用德语中的同义词uber替代）。            
<pre>function Shape(){
    this.name='shape';
}

Shape.prototype.toString=function(){
    return this.name;
};

function Triangle(side,height){
    this.name='triangle';
    this.side=side;
    this.height=height;
}
     var F=function (){
         this.getArea=function(){
         return this.side*this.height/2;
         };
         this.uber=Shape.prototype;
     };
     F.prototype=Shape.prototype;
     F.uber=Shape.prototype;
     Triangle.prototype=new F();
     Triangle.prototype.constructor=Triangle;</pre>       

<p> <strong>工具集:</strong>       </p>
 <pre>function extend(Child,Parent){
     var F=function(){};
     F.prototype=Parent.prototype;
     Child.prototype=new F();
     Child.prototype.constructor=Child;
     Child.uber=Parent.prototype;
 }</pre>
</li>
<li><p>前面介绍了原型链继承模式，在模拟传统继承方式时还可以简单粗暴的将父类的原型中成员直接拷贝到子类原型中。<br><strong>工具集:</strong>     </p>
<pre>function extend2(Child,Parent){
    var c=Child.prototype,p=Parent.prototype;
    for(var i in p){
        c[i]=p[i]
    }
    c.uber=p;
}</pre>        
值得注意的是prototype中的constructor属性是不可枚举的，在for-in循环中不会被拷贝，子类保有自己正确的constructor指向。      
以上拷贝很明显是浅拷贝，当父类中有对象成员，甚至对象成员中还有对象子成员时，以上拷贝会造成引用传递，子类在修改属性时引发父类属性同时变化，下面介绍深拷贝工具集。         
<strong>工具集:</strong>
<pre>function deepcopy(p,c){
    c = c||{};
    for(var i in p){
        if(p.hasOwnProperty(i)){
            if(typeOf p[i] ==== 'object'){
                c[i] =Array.isArray(p[i])?[]:{};
                deepCopy(p[i],c[i]);
            }else{
                c[i]=p[i];
            }
        }
    }
    return c;
}</pre>       
<pre>ES5中实现了isArray，为了向下兼容补充工具集如下(全局)：       
if(Array.isArray !=='function'){
    Array.isArray = function(args){
        return Object.prototype.toString.call(args) === '[object Array]';
    };
}</pre>       </li>
<li><p>前面介绍了原型链继承模型和简单的成员拷贝模式，我们在继承当中不仅要复用父类的方法还会有增加新方法的需求，因此结合两种方式模式增强我们的继承工具集如下：<br><strong>工具集(基于构造器模式):</strong>       </p>
<pre>function extendX(P,stuff){
var n;
function F(){};
F.prototype=P.prototype;
n=new F();
n.uber=P.prototype;

for(var i in stuff){
    n[i]=stuff[i]
}
return n;
}</pre>             

</li>
</ol>
<p><strong>工具集(基于对象模式):</strong>       </p>
<pre>function extendX(o,stuff){
    var n;
    function F(){};
    F.prototype=o;
    n=new F();
    n.uber=o;

    for(var i in stuff){
        n[i]=stuff[i]
    }
    return n;
}</pre>   

<ol>
<li>借用构造器+原型复制 模式实现继承<br>借用构造器使得我们可以在子类构造器中调用福构造器，但是此处apply调用是方法调用，不会继承父类的原型属性，为了补充这块空缺，可以使用extend2或者deepCopy函数进行原型拷贝，让子类继承到父类的成员与原型成员。<br>借用构造器形式举例:        <pre>function Triangle(){
    Shape.apply(this,arguments);
}</pre>











</li>
</ol>
]]></content>
        
        <categories>
            
            <category> 前端开发 </category>
            
            <category> javaScript </category>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[对象]]></title>
        <url>http://zhangyan123.github.io/2016/09/20/javaScript%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的-javaScript是基于原型-prototype-面向对象的动态语言（对象）"><a href="#你应该知道的-javaScript是基于原型-prototype-面向对象的动态语言（对象）" class="headerlink" title="你应该知道的: javaScript是基于原型(prototype)面向对象的动态语言（对象）"></a>你应该知道的: javaScript是基于原型(prototype)面向对象的动态语言（对象）</h1><ul>
<li>JS对象中的属性可以 <strong>动态</strong> 得进行增、删(delete)、修改；</li>
<li>JS中的数组实质为键值由0开始自增的特殊对象，数组一般用来存放有规律的一组数据，无需特殊的索引；</li>
<li>对象与数组的不同在于键值可以自定义；</li>
<li>对象的创建：<ul>
<li>使用字面量{}创建</li>
<li>使用new+构造函数创建</li>
<li>构造函数举例      <pre>function Constr(name){
          this.name=name;
          this.say=function(){
              return this.name;
          };
  }</pre></li>
<li>实例化举例   <pre>var instance = new Constr("zhangyan");
  instance.say();//"zhangyan"</pre>     </li>
<li>实例化过程 <strong>模拟</strong><br>当我们使用new操作符调用函数时，js默默完成了创建新对象并初始化新对象的操作<br>   <pre>var this={};<br>  this.name=arguments[0];<br>  this.say=fucntion(){<pre><code>return this.name;
</code></pre>  };<br>  this._proto_=Constr.prototype;<br>  return this;</pre> 以上为伪代码只可意会，并不代表真实代码 </li>
<li><pre>instance instanceOf Constr;//true<br>typeOf instance===”object”;<br>instance.constructor===Constr//true constructor</pre>属性继承自Object</li>
</ul>
</li>
<li>你应该记住的关于内建对象扩展的讨论：<blockquote>
<p>最常用例子：实现让老式浏览器支持新功能，而且应该是ECMAScript委员会标准化了的，为现代浏览器支持的新功能，例如让IE支持ES5中的方法，这类扩展叫做shims或者polyfills.<strong>在进行原型扩展之前需要先检查该方法是否已存在</strong></p>
</blockquote>
</li>
<li>你应该记住的内建对象方法：<br> 1.Date<br> 属性(1):<br> constructor      所建立对象的函数参考<br> prototype       能够为对象加入的属性和方法<br> 方法(43):<br> getDay()        返回一周中的第几天(0-6)<br> getYear()       返回年份.2000年以前为2位,2000(包含)以后为4位<br> getFullYear()     返回完整的4位年份数<br> getMonth()      返回月份数(0-11)<br> getDate()       返回日(1-31)<br> getHours()       返回小时数(0-23)<br> getMinutes()      返回分钟(0-59)<br> getSeconds()      返回秒数(0-59)<br> getMilliseconds() 返回毫秒(0-999)<br> getUTCDay()      依据国际时间来得到现在是星期几(0-6)<br> getUTCFullYear()    依据国际时间来得到完整的年份<br> getUTCMonth()     依据国际时间来得到月份(0-11)<br> getUTCDate()      依据国际时间来得到日(1-31)<br> getUTCHours()     依据国际时间来得到小时(0-23)<br> getUTCMinutes()    依据国际时间来返回分钟(0-59)<br> getUTCSeconds()    依据国际时间来返回秒(0-59)<br> getUTCMilliseconds()依据国际时间来返回毫秒(0-999)<br> getTime()       返回从1970年1月1号0:0:0到现在一共花去的毫秒数<br> getTimezoneoffset() 返回时区偏差值,即格林威治平均时间(GMT)与运行脚本的计算机所处时区设置之间相差的分钟数)<br> parse(dateString)   返回在Date字符串中自从1970年1月1日00:00:00以来的毫秒数<br> setYear(yearInt)    设置年份.2位数或4位数<br> setFullYear(yearInt)设置年份.4位数<br> setMonth(monthInt) 设置月份(0-11)<br> setDate(dateInt)    设置日(1-31)<br> setHours(hourInt) 设置小时数(0-23)<br> setMinutes(minInt) 设置分钟数(0-59)<br> setSeconds(secInt) 设置秒数(0-59)<br> setMilliseconds(milliInt) 设置毫秒(0-999)<br> setUTCFullYear(yearInt) 依据国际时间来设置年份<br> setUTCMonth(monthInt) 依据国际时间来设置月(0-11)<br> setUTCDate(dateInt)     依据国际时间来设置日(1-31)<br> setUTCHours(hourInt)    依据国际时间来设置小时<br> setUTCMinutes(minInt) 依据国际时间来设置分钟<br> setUTCSeconds(secInt)    依据国际时间来设置秒<br> setUTCMilliseconds(milliInt)依据国际时间来设置毫秒<br> setTime(timeInt)    设置从1970年1月1日开始的时间.毫秒数<br> toGMTString()     根据格林威治时间将Date对象的日期(一个数值)转变成一个GMT时间字符串,如:Weds,15 June l997 14:02:02 GMT<br> toUTCString()     根据通用时间将一个Date对象的日期转换为一个字符串<br> toLocaleString()    把Date对象的日期(一个数值)转变成一个字符串,使用所在计算机上配置使用的特定日期格式<br> toSource()       显示对象的源代码<br> toString()       将日期对象转换为字符串<br> UTC(yyyy, mm, dd, hh, mm, ss, msec)返回从格林威治标准时间到指定时间的差距,单位为毫秒<br> valueOf()       返回日期对象的原始值<br> 2.Math<br> 属性:<br> constructor      所建立对象的函数参考<br> prototype       能够为对象加入的属性和方法<br> E           欧拉常量,自然对数的底(约等于2.718)<br> LN2          2的自然对数(约等于0.693)<br> LN10          10的自然对数(约等于2.302)<br> LOG2E         以2为底的e的对数.(约等于1.442)<br> LOG10E         以10为底的e的对数(约等于0.434)<br> PI           ∏的值(约等于3.14159)<br> SQRT1_2        1/2(0.5)的平方根(即l除以2的平方根,约等于o.707)<br> SQRT2         2的平方根(约等于1.414)<br> 方法:<br> abs(x)     返回数字的绝对值<br> acos(x)    返回数字的反余弦值<br> asin(x)    返回数字的反正弦值<br> atan(x)    返回位于-PI/2 和 PI/2 的反正切值<br> atan2(y,x) 返回（x,y）位于 -PI 到 PI 之间的角度<br> ceil(x)    返回 x 四舍五入后的最大整数<br> cos(x)     返回一个数字的余弦值<br> exp(x)     返回 E^x 值<br> floor(x)    返回 x 四舍五入后的最小整数<br> log(x)     返回底数为E的自然对数<br> max(x,y)    返回 x 和 y 之间较大的数<br> min(x,y)    返回 x 和 y 之间较小的数<br> pow(x,y)    返回 y^x 的值<br> random()    返回位于 0 到 1 之间的随机函数<br> round(x)    四舍五入后取整<br> sin(x)     返回数字的正弦值<br> sqrt(x)    返回数字的平方根<br> tan(x)     返回一个角度的正切值<br> toSource() 显示对象的源代码<br> valueOf() 返回数学对象的原始值<br> 3.Number<br> 属性:<br> MAX_VALUE       The largest possible value a number in JavaScript can have 1.7976931348623157E+308<br> MIN_VALUE       The smallest possible value a number in JavaScript can have 5E-324<br> NaN          Equal to a value that is not a number.<br> NEGATIVE_INFINITY A value that is less than MIN_VALUE.<br> POSOTIVE_INFINITY A value that is greater than <code>MAX<em>VALUE</em></code>.<br> prototype       A static property of the Number object<br> 方法:<br> toString       Returns a string representing the specified object<br> valueOf()      返回数学对象的原始值<br> 4.Boolean<br> 属性:<br> constructor 所建立对象的函数参考<br> prototype    能够为对象加入的属性和方法<br> 方法:<br> toSource()    显示对象的源代码<br> toString()    将布尔值转换为字符串,并且返回结果<br> valueOf()    返回布尔对象的原始值<br> 5.String<br> 属性:<br> constructor 所建立对象的函数参考<br> prototype    能够为对象加入的属性和方法<br> length      返回字符串的字符长度<br> 方法(20):<br> anchor(“name”)用来把字符串转换为HTML锚点标记内<code>(&lt;A NAME=&gt;)</code><br> big()      把字符串中的文本变成大字体<code>(&lt;BIG&gt;)</code><br> blink()     把字符串中的文本变成闪烁字体<code>(&lt;BLINK&gt;)</code><br> bold()      把字符串中的文本变成黑字体<code>(&lt;B&gt;)</code><br> fixed()     把字符串中的文本变成固定间距字体,即电报形式<code>(&lt;TT&gt;)</code><br> fontcolor(color)设置字符串中文本的颜色<code>(&lt;FONT COLOR=&gt;)</code><br> Fontsize(size) 把字符串中的文本变成指定大小<code>(&lt;FONTSIZE=&gt;)</code><br> italics()    把字符串中的文本变成斜字体<code>(&lt;I&gt;)</code><br> Link(url)用来把字符串转换-HTML链接标记中<code>(&lt;A HREF=&gt;)</code><br> small()     把字符串中的文本变成小字体<code>(&lt;SMALL&gt;)</code><br> strike()     把字符串中的文本变成划掉字体<code>(&lt;STRIKE&gt;)</code><br> sub()      把字符串中的文本变成下标(subscript)字体<code>(&lt;SUB&gt;)</code><br> sup()      把字符串中的文本变成上标(superscript)字体<code>(&lt;SUP&gt;)</code><br> charAt(index) 返回指定索引处的字符<br> charCodeAt(index)返回一个整数,该整数表示String对象中指定位置处的字符的Unicode编码<br> concat(string2)连接两条或多条字符串<br> fromCharCode(num1, num2, …, numN)获取指定的Unicode值并返回字符串<br> indexOf(searchString, startIndex) 返回字符串中第一个出现指定字符串的位置<br> lastlndexOf(searchString, startIndex) 返回字符串中最后一个出现指定字符串的位置<br> match(regex) 在字符串中查找指定值<br> replace(regex, newString)将字符串中的某些字符替换成其它字符<br> search(regex) 针对某执行值对字符串进行查找<br> slice(startIndex, endIndex)将部分字符抽出并在新的字符串中返回剩余部分<br> split(delimiter)将字符串分配为数组<br> substr(startIndex, length) 从startIndex取,取length个字符<br> substring(startIndex, endIndex) 从startIndex和endIndex之间的字符,不包括endIndex<br> toLowerCase() 把字符串中的文本变成小写<br> toUpperCase() 把字符串中的文本变成大写<br> toSource()    显示对象的源代码<br> valueOf()    返回字符串对象的原始值<br> 6.Array<br> 属性:<br> constructor 所建立对象的函数参考<br> prototype    能够为对象加入的属性和方法<br> index      For an array created by a regular expression match, the zero-based index of the match in the string.<br> input      For an array created by a regular expression match, reflects the original string against which the regular expression was matched.<br> length      获取数组元素的个数,即最大下标加1<br> 方法(13):<br> concat(array1,arrayn)将两个或两个以上的数组值连接起来,合并后返回结果<br> join(string) 将数组中元素合并为字符串,string为分隔符.如省略参数则直接合并,不再分隔<br> pop()      移除数组中的最后一个元素并返回该元素<br> push(value) 在数组的末尾加上一个或多个元素,并且返回新的数组长度值<br> reverse()    颠倒数组中元素的顺序,反向排列<br> shift()     移除数组中的第一个元素并返回该元素<br> slice(start, deleteCount, [item1[, item2[,…[,itemN]]]]) 返从一个数组中移除一个或多个元素,如果必要,在所移除元素的位置上插入新元素,返回所移除的元素<br> sort(compare Function) 在未指定排序号的情况下,按照元素的字母顺序排列,如果不是字符串类型则转换成字符串再排序,返回排序后的数组<br> splice()     为数组删除并添加新的元素<br> toSource()    显示对象的源代码<br> toString()    将数组所有元素返回一个字符串,其间用逗号分隔<br> unshift(value)为数组的开始部分加上一个或多个元素,并且返回该数组的新长度<br> valueOf()    返回数组对象的原始值<br> 7.RegExp<br> 属性:<br> $1, …, $9 Parenthesized substring matches, if any.<br> $        See input.<br> $*        See multiline.<br> $&amp;        See lastMatch.<br> $+        See lastParen.<br> $`        See leftContext.<br> $’        See rightContext.<br> global      Whether or not to test the regular expression against all possible matches in a string, or only against the first.<br> ignoreCase    Whether or not to ignore case while attempting a match in a string.<br> input      The string against which a regular expression is matched.<br> lastIndex    The index at which to start the next match.<br> lastMatch    The last matched characters.<br> lastParen    The last parenthesized substring match, if any.<br> leftContext The substring preceding the most recent match.<br> multiline    Whether or not to search in strings across multiple lines.<br> rightContext The substring following the most recent match.<br> source      The text of the pattern.<br> 方法:<br> compile     Compiles a regular expression object.<br> exec       Executes a search for a match in its string parameter.<br> test       Tests for a match in its string parameter<br> 8.Function<br> 属性:<br> arguments    An array corresponding to the arguments passed to a function.<br> arity      Indicates the number of arguments expected by the function.<br> caller      Specifies which function called the current function.<br> prototype    Allows the addition of properties to a Function object.<br> 方法:<br> toString     Returns a string representing the specified object.<br> 9.Object<br> 属性:<br> constructor Specifies the function that creates an object’s prototype.<br> prototype    Allows the addition of properties to all objects.<br> 方法:<br> eval       Evaluates a string of JavaScript code in the context of the specified object.<br> toString     Returns a string representing the specified object.<br> unwatch     Removes a watchpoint from a 属性源 the object.<br> valueOf     Returns the primitive value of the specified object.<br> watch      Adds a watchpoint to a 属性源 the object.<br> 10.全局<br> 属性:<br> Infinity     指定一个正负无穷大的数值<br> NaN       指定一个 “非数字” 值<br> undefined    指定一个未被赋值的变量<br> 方法:<br> decodeURI()       为加密的URI进行解码<br> decodeURIComponent() 为加密的URI组件解码<br> encodeURI()       将字符串加密为URI<br> encodeURIComponent() 将字符串加密为URI组件<br> escape(string)      加密一个字符串<br> unescape()        使用escape()对一个字符串进行解码<br> eval(string)       判断一个字符串并将其以脚本代码的形式执行<br> isFinite(number)     检测一个值是否为一个有限数字,返回True或False<br> isNaN(string)      检测一个值是否不是一个有限数字<br> Number()         将一个对象的值转换为一个数字<br> parseFloat(string)    将一个字符串解析为一个浮点数字<br> parseInt(string)     将一个字符串解析为一个整数,不是四舍五入操作,而是切尾<br> String(object)      将一个对象值转换为一个字符串<br> number(object)<br> 11.事件<br> 属性:<br> a.窗口事件,只在body和frameset元素中才有效<br> onload      页面或图片加载完成时<br> onunload     用户离开页面时<br> b.表单元素事件,在表单元素中才有效<br> onchange     框内容改变时<br> onsubmit     点击提交按钮时<br> onreset     重新点击鼠标按键时<br> onselect     文本被选择时<br> onblur      元素失去焦点时<br> onfocus     当元素获取焦点时<br> c.键盘事件,在base,bdo,br,frame,frameset,head,html,iframe,meta,param,script,style,title元素里都无效<br> onkeydown    按下键盘按键时<br> onkeypress    按下或按住键盘按键时<br> onkeyup     放开键盘按键时<br> d.在base,bdo,br,frame,frameset,head,html,iframe,meta,param,script,style,title元素里都无效<br> onclick     鼠标点击一个对象时<br> ondblclick    鼠标双击一个对象时<br> onmousedown 鼠标被按下时<br> onmousemove 鼠标被移动时<br> onmouseout    鼠标离开元素时<br> onmouseover 鼠标经过元素时<br> onmouseup    释放鼠标按键时<br> e.其他<br> onresize     当窗口或框架被重新定义尺寸时<br> onabort     图片下载被打断时<br> onerror     当加载文档或图片时发生错误时</li>
</ul>
]]></content>
        
        <categories>
            
            <category> 前端开发 </category>
            
            <category> javaScript </category>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[函数]]></title>
        <url>http://zhangyan123.github.io/2016/09/13/javaScript%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的：函数"><a href="#你应该知道的：函数" class="headerlink" title="你应该知道的：函数"></a>你应该知道的：函数</h1><ul>
<li>函数声明的组成部分：关键字function、函数名、参数、函数体、return（如果没有显示的返回值，JS默认返回undefined）</li>
<li>函数声明与函数表达式区别在于声明会提升，而表达式在预编译中会被跳过，只有var a =function(){//函数体}中的变量a得到了变量声明提升，a===undefined;</li>
<li>函数的参数分为形参和实参，eg:function add(a,b){return a+b;}  中形参的个数为add.length，而使用时传入实参的个数为arguments.length，arguments是函数内建变量，它是一个承装实际参数的类数组而非真正的数组，一般为了方便使用数组的方法我们会使用var args=Array.prototype.slice.call(arguments);将类数组转换为真正的数组。</li>
<li><p>枚举JS内建函数注意事项</p>
<ul>
<li>parseInt(requireArg,radix)第二个参数用于指定解析整数的进制，默认十进制，ES5之前有fix=0x||0时候易造成默认进制改变为十六或八导致的错误。ES5已经修复了八进制的默认表示法，但是使用此函数时仍需注意,不能解析为整数时返回NaN。</li>
<li>parseFloat()只支持解析为十进制数,但parseFloat()可以识别指数型字符串parseFloat(‘1e1’)===10</li>
<li>isNaN()确定输入值是否为可参与计算的数字，因此此函数可以用来检测parseInt()和parseFloat()返回调用成功与否。</li>
<li>isFinite()用于检测既非Infinit又非NaN的数字</li>
<li>URI的编码与反编码 encodeURI()/encodeURIComponent()/decodeURI()/decodeURIComponent</li>
</ul>
</li>
<li><p>函数的两大特征：</p>
<ul>
<li>函数是对象，唯一的不同是它可以被调用；</li>
<li>函数定义局部作用域；</li>
</ul>
</li>
<li>强烈建议使用“单一var”模式在函数顶部声明函数用的局部变量，方便已近函数遍阅读到该区域所有用的变量的定义。避免变量声明提升带来的变量使用不恰当的混淆问题。</li>
<li>将A函数作为参数传递给B函数,并由B函数来执行A(A承担B函数中的部分处理功能特别是在循环中调用同一种方法时常用回调函数节省循环次数)，此时A函数叫做B函数的回调函数。</li>
<li>闭包实现：(将函数内部的函数暴露在全局环境中)<ul>
<li>return inner();</li>
<li>全局变量=inner();</li>
</ul>
</li>
<li><p>使用闭包的注意事项：</p>
<ul>
<li>内部函数保存的是作用域本身，也不是定义函数时的快照，因此在外调用内部函数时多次调用结果可以不同；</li>
<li>循环中使用闭包：要记住闭包记住的是变量而非定义闭包时的固定值，当调用闭包时其中的变量值为该变量最近被赋予的值；</li>
<li>闭包可以用于访问私有变量，保证该变量的值只通过闭包进行访问，并保证在全局可以访问到此变量。</li>
</ul>
</li>
<li><p>每个函数都一定有return值，没有显示返回的js自动补全为undefined，return false为终止执行，return true为执行默认操作，可以return局部变量的值（栈中的值）或者函数（闭包），但不能返回局部引用值（引用的对象存储在堆中，函数返回之后堆中对象被清理，引用值体现为无效）。</p>
</li>
</ul>
]]></content>
        
        <categories>
            
            <category> 前端开发 </category>
            
            <category> javaScript </category>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[基本数据类型（5）]]></title>
        <url>http://zhangyan123.github.io/2016/09/11/javaScript%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的：基本数据类型常用技巧"><a href="#你应该知道的：基本数据类型常用技巧" class="headerlink" title="你应该知道的：基本数据类型常用技巧"></a>你应该知道的：基本数据类型常用技巧</h1><ul>
<li>5种基本数据类型 Number、String、Boolean、null、undefined剩下的都是复杂类型</li>
<li>原生9种内建构造函数：<ul>
<li>数据封装类对象：Number、String、Boolean、Object、Array</li>
<li>工具类对象：Math、Date、RegExp</li>
<li>错误类对象：error</li>
</ul>
</li>
<li>使用typeof操作符可以检测数据类型，new出来的任何种类的对象都呈现为[object object]，尽量使用字面量创建方式以便检测类型</li>
<li>3e+3=3000</li>
<li>数字中有两个特例 NaN!==NaN  Infinity+（-Infinity）===NaN  数字%0==Infinity</li>
<li>字符串转为数字 parseInt(“10Shjksah”)===10  简便方式：  +”10”</li>
<li>数字转字符串 “”+123===“123”</li>
<li>双重取反操作可以取到任何值对应的布尔值 eg:！！1===true</li>
<li>6种falsy值：<ul>
<li>“”</li>
<li>null</li>
<li>undefined</li>
<li>0</li>
<li>NaN</li>
<li>false<br>除以上falsy值之外的数据都是truthy值包括对象和falsy值字符串eg:”false”===true  </li>
</ul>
</li>
<li>经常使用的惰性求值法：<ul>
<li>||用于检测对象是否存在若不存在赋予初始值eg:  var a = b||{};</li>
<li>a() &amp;&amp; b() :如果执行a()后返回true，则执行b()并返回b的值,此用法与？：三元运算符经常用于简化运算步骤；如果执行a()后返回false，则整个表达式返回a()的值，b()不执行；<br>a() || b() :如果执行a()后返回true，则整个表达式返回a()的值，b()不执行；如果执行a()后返回false，则执行b()并返回b()的值；<br>&amp;&amp; 优先级高于 ||</li>
</ul>
</li>
<li>typeof null===object ;typeof undefined===undefined</li>
<li>数组可以用于取字符串的某位字符’123’[1]===”2”,数组其实为key值从0开始递增的对象</li>
<li>for-in方法是为了遍历对象而设计，会遍历原型链，注意使用hasOwnProperty()  </li>
</ul>
]]></content>
        
        <categories>
            
            <category> 前端开发 </category>
            
            <category> javaScript </category>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[表达式与语句]]></title>
        <url>http://zhangyan123.github.io/2016/09/10/javaScript%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</url>
        <content type="html"><![CDATA[<h1 id="你应该知道的：变量、表达式与语句"><a href="#你应该知道的：变量、表达式与语句" class="headerlink" title="你应该知道的：变量、表达式与语句"></a>你应该知道的：变量、表达式与语句</h1><h2 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h2><ul>
<li><code>var a ;</code> 声明（分配栈空间命名为a）。</li>
<li>定义（也称作初始化）<code>a = 1;</code>（为声明的变量赋【值】）。  </li>
</ul>
<blockquote>
<p><strong>注：</strong></p>
<ul>
<li>只声明未定义与未声明的变量在使用时均为undefined（JS的一种基本数据类型，JS是一段一段执行的（以script标签来分割），执行每一段之前，都有一个“预编译”，预编译干的活是：声明所有var变量（初始为undefined），解析定义式函数语句。）。</li>
<li>最佳时间的声明语句发生在作用域（函数）最开始位置，且使用一个var及逗号分隔的一条语句，方便查看此作用域中变量也避免【变量提升】机制带来的意外事件。</li>
<li>JS的变量名是区分大小写的，可包含字母，数字，下划线和$，但不能以数字开头。            </li>
</ul>
</blockquote>
<h2 id="表达式与语句"><a href="#表达式与语句" class="headerlink" title="表达式与语句"></a>表达式与语句</h2><p>表达式中使用运算符产生结果值，多个表达式之间使用逗号分隔；语句是代码执行的最小单元组成，程序就是由一系列语句组成的代码执行块，语句之间使用分号分隔。</p>
<blockquote>
<p><strong>注：</strong>   </p>
<ul>
<li>表达式可以作为值出现在任何位置；</li>
<li>表达式是求值运算个中变量在运行前不得而知，故在JS预编译期间不进行解释，直接跳过；语句中声明的部分是会在预编译中进行解释的，执行过程中不再理会已解释部分的语句；</li>
<li>因为现在的JS有插入分号机制，已经不要求代码中的语句必须使用分号结尾了，为了方便区分表达式与表达式语句，JS规定，使用（）包裹以{}包裹或者以function开头的代码理解为表达式；以一元运算符，比如！或者+开头的代码被理解为表达式，与（）不之处是运算符会改变表达式结果。</li>
</ul>
</blockquote>
]]></content>
        
        <categories>
            
            <category> 前端开发 </category>
            
            <category> javaScript </category>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[markdown个人常用语法总结]]></title>
        <url>http://zhangyan123.github.io/2016/09/01/markdown%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
        <content type="html"><![CDATA[<blockquote>
<p>为了方便写作查找，查阅文档之后总结出自己常用的markdown语法如下  </p>
</blockquote>
<h1 id="使用-标记标题"><a href="#使用-标记标题" class="headerlink" title="使用#标记标题"></a>使用#标记标题</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul>
<li>星号*可以标记列表</li>
</ul>
<ul>
<li>加号+也可以标记列表</li>
</ul>
<ul>
<li>减号-也可以标记列表</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol>
<li>数字接英文点号，每项后面记得加至少两个空格   </li>
</ol>
<blockquote>
<p>在首行出现数字-英文句点-空白时  </p>
<p>eg:<code>1987. </code>应写为<code>1987\.</code>以与列表格式进行区分  </p>
</blockquote>
<h2 id="代码及区块"><a href="#代码及区块" class="headerlink" title="代码及区块"></a>代码及区块</h2><ul>
<li><blockquote>
<p>>区块引用</p>
</blockquote>
</li>
<li><p>分行方式为每行结尾至少两个空格键+回车键    </p>
</li>
<li><p>使用pre+code包裹，可以保持代码粘贴时的缩进格式   </p>
<hr>
<hr>
</li>
<li><p>如上的分割线使用<code>* * *</code>或者<code>- - -</code>单独一行制成,符号之间可以自由添加空格</p>
</li>
<li><code>html</code>可以直接使用tab上面的<code>`</code>包裹小段代码作为代码引用的标志，注意不要与<code>‘</code>英文单引号混淆</li>
</ul>
<h2 id="嵌入带连接的元素"><a href="#嵌入带连接的元素" class="headerlink" title="嵌入带连接的元素"></a>嵌入带连接的元素</h2><ul>
<li><p><a href="https://zhangyan123.github.io/&quot;dailyblog&quot;">myBlog</a><br>以上内联链接制作方式如下<br><code>[myBlog](<a href="https://zhangyan123.github.io/&quot;dailyblog">https://zhangyan123.github.io/&quot;dailyblog</a>“)</code>支持相对路径<br>相似的图片嵌入，形式上只是在链接前面加一个感叹号!</p>
</li>
<li><p><img src="/images/default-1.png" alt="myBlog"><br>以上图片嵌入的制作方式如下<br><code>![myBlog](<a href="https://zhangyan123.github.io/images/default-1.png">https://zhangyan123.github.io/images/default-1.png</a>)</code></p>
</li>
<li>直接嵌入一个暴露的连接<a href="http://example.com" target="_blank" rel="external">http://example.com</a> 可以使用<code>&lt; <a href="http://example.com" target="_blank" rel="external">http://example.com</a> ></code>方式，同样的嵌入邮箱地址可以使用直接使用<code>&lt; address@example.com ></code>  </li>
</ul>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><blockquote>
<p>我们会发现markdown语法中<code>*</code>与<code>-</code>具有很多互通的功能，上文中提到的无序列表、分割线均如此，此处要说明的强调标记方式中易与此规律混淆，请务必分清减号-与下滑线_的适用场景。   </p>
</blockquote>
<ul>
<li><code> *需要强调的文字*</code>与 <code> _需要强调的文字_</code>都可以实现<em>需要强调的文字</em>的效果，注意是下划线不是减号。  </li>
<li><code> **需要强调的文字**</code>与 <code> __需要强调的文字__</code>都可以实现<strong>需要强调的文字</strong>的效果，再次强调是下划线不是减号。  </li>
<li><del>删除线</del></li>
</ul>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code>| 排序方法 | 平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性 |//表头
|:-----|:-----|:-----|:-----|:-----|:-----|//对齐方式|:-----|左对齐，|:-----:|居中，|-----:|右对齐

| 冒泡排序 | O(n²) | O(nlogn) | O(n²) | O(1) | 稳定 |//单元格数据
| 简单选择 | O(n²) | O(n²) | O(n²) | O(1) | 稳定 |
| 直接插入 | O(n²) | O(n) | O(n²) | O(1) | 稳定 |
| 希尔排序 | O(nlogn)~O(n²) | O(n^1.3) | O(n²) | O(1) | 不稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 不稳定 |
| 快速排序 | O(nlogn) | O(nlogn) | O(n²) | O(nlogn)~O(n) | 不稳定 |</code></pre> 

<table>
<thead>
<tr>
<th style="text-align:left">排序方法</th>
<th style="text-align:left">平均情况</th>
<th style="text-align:left">最好情况</th>
<th style="text-align:left">最坏情况</th>
<th style="text-align:left">辅助空间</th>
<th style="text-align:left">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:left">O(n²)</td>
<td style="text-align:left">O(nlogn)</td>
<td style="text-align:left">O(n²)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td style="text-align:left">简单选择</td>
<td style="text-align:left">O(n²)</td>
<td style="text-align:left">O(n²)</td>
<td style="text-align:left">O(n²)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td style="text-align:left">直接插入</td>
<td style="text-align:left">O(n²)</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n²)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">稳定</td>
</tr>
<tr>
<td style="text-align:left">希尔排序</td>
<td style="text-align:left">O(nlogn)~O(n²)</td>
<td style="text-align:left">O(n^1.3)</td>
<td style="text-align:left">O(n²)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">不稳定</td>
</tr>
<tr>
<td style="text-align:left">堆排序</td>
<td style="text-align:left">O(nlogn)</td>
<td style="text-align:left">O(nlogn)</td>
<td style="text-align:left">O(nlogn)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">不稳定</td>
</tr>
<tr>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">O(nlogn)</td>
<td style="text-align:left">O(nlogn)</td>
<td style="text-align:left">O(nlogn)</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">不稳定</td>
</tr>
<tr>
<td style="text-align:left">快速排序</td>
<td style="text-align:left">O(nlogn)</td>
<td style="text-align:left">O(nlogn)</td>
<td style="text-align:left">O(n²)</td>
<td style="text-align:left">O(nlogn)~O(n)</td>
<td style="text-align:left">不稳定</td>
</tr>
</tbody>
</table>
<div style="color：white;background:#ccc;"><h2>备注<h2><em>markdown文档中可以直接使用html标签和css样式,你会发现写在markdown中的样式直接应用在了文档中</em></h2></h2></div> 
]]></content>
        
        <categories>
            
            <category> 写作 </category>
            
            <category> markdown </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 写作 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[lavarel<一>环境搭建]]></title>
        <url>http://zhangyan123.github.io/2016/08/31/laravel%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
        <content type="html"><![CDATA[<a id="more"></a>
<p>lavarel学习场所<a href="http://laravelacademy.org/" target="_blank" rel="external">lavarel学院</a>下载文档查看安装与配置方法</p>

<ol>
<li>安装wamp，确保php版本要大于等于5.59；</li>
<li>安装composer，通过composer安装laravel<code>。composer global require &quot;laravel/installer&quot;</code>确保~/.composer/vendor/bin在系统路径中，否则不能在任意路径调用 laravel 命令。；</li>
<li>安装好以上环境，可以使用git clone已有的项目到本地，将public指定为服务器的根目录，便可以在本地查看项目，并使用git分布式管理项目了。</li>
<li>更改完服务器根目录之后，localhost页面显示缺少依赖文件，进入项目文件夹，<code>composer update</code>可以解决此问题。<br></li>
</ol>
]]></content>
        
        <categories>
            
            <category> 前端开发 </category>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> larabel </tag>
            
        </tags>
        
    </entry>
    
    
    
    
    <entry>
        <title><![CDATA[demo]]></title>
        <url>http://zhangyan123.github.io/demo/index.html</url>
        <content type="html"></content>
    </entry>
    
    
</search>
